<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ultimate Golden AR Tree</title>
    
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* ç”»ä¸­ç”»æ‘„åƒå¤´ (å³ä¸Šè§’) */
        #input-video {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 120px;
            height: auto;
            aspect-ratio: 3/4;
            object-fit: cover;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            transform: scaleX(-1);
            z-index: 20;
            background: #222;
        }

        /* ä¸»ç”»å¸ƒ */
        #three-canvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 15;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* èƒ½é‡æ¡ (éœ‡åŠ¨è§¦å‘åé¦ˆ) */
        #energy-bar-container {
            position: absolute;
            bottom: 100px;
            width: 200px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            overflow: hidden;
            display: none; /* åˆå§‹éšè— */
        }
        #energy-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff8800, #ffd700);
            transition: width 0.1s;
        }

        #instruction {
            margin-top: 30px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 24px;
            border-radius: 30px;
            text-align: center;
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(4px);
            transition: all 0.3s;
        }

        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffd700;
            flex-direction: column;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 3px solid #333; border-top: 3px solid #ffd700;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>
    <canvas id="three-canvas"></canvas>

    <div id="ui-layer">
        <div id="instruction">ğŸ– ä¼¸æ‰‹å³å¯å”¤é†’åœ£è¯æ ‘</div>
        
        <div id="energy-bar-container">
            <div id="energy-bar"></div>
        </div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div>å¯åŠ¨ç²’å­å¼•æ“...</div>
    </div>

    <script>
        // === å…¨å±€é…ç½® ===
        const CONFIG = {
            wishText: "Merry Christmas", // ç²’å­é‡ç»„åçš„æ–‡å­—
            shakeThreshold: 0.08,        // éœ‡åŠ¨æ£€æµ‹é˜ˆå€¼
            spreadThreshold: 0.18,       // æ‰‹æŒ‡å¼ å¼€é˜ˆå€¼
            energyDecay: 0.02,           // èƒ½é‡è¡°å‡é€Ÿåº¦
            energyGain: 0.15             // èƒ½é‡å¢åŠ é€Ÿåº¦
        };

        const state = {
            handDetected: false,
            // æ‰‹éƒ¨ä½ç½®å¹³æ»‘
            targetPos: new THREE.Vector3(0, 0, 0),
            currentPos: new THREE.Vector3(0, 0, 0),
            // åŠ¨ä½œçŠ¶æ€
            isSpreading: false,
            shakeEnergy: 0,
            isExploded: false,
            // ç²’å­é‡ç»„é˜¶æ®µ
            textParticles: [] 
        };

        const canvas = document.getElementById('three-canvas');
        const instructionEl = document.getElementById('instruction');
        const energyContainer = document.getElementById('energy-bar-container');
        const energyBar = document.getElementById('energy-bar');

        // Three.js å˜é‡
        let scene, camera, renderer;
        let treeGroup, particles, ornaments, starMesh;
        let particleGeo, particleMat;
        let clock = new THREE.Clock();

        // çº¹ç†ç”Ÿæˆ
        function createTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.4,'rgba(255,215,0,0.5)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        const glowTex = createTexture();

        // æ–‡æœ¬ç²’å­ç”Ÿæˆå™¨
        function createTextTargets(text) {
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            const fontSize = 80;
            c.width = 1024; c.height = 256;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, c.width/2, c.height/2);

            const data = ctx.getImageData(0,0,c.width,c.height).data;
            const targets = [];
            // é‡‡æ ·åƒç´ ç‚¹
            for(let y=0; y<c.height; y+=4) {
                for(let x=0; x<c.width; x+=4) {
                    const alpha = data[(y*c.width+x)*4 + 3];
                    if(alpha > 128) {
                        // æ˜ å°„åˆ° 3D ç©ºé—´
                        targets.push(new THREE.Vector3(
                            (x - c.width/2) * 0.015,
                            -(y - c.height/2) * 0.015 + 0.5, // ç¨å¾®æŠ¬é«˜
                            0
                        ));
                    }
                }
            }
            return targets;
        }

        // === Three.js åˆå§‹åŒ– ===
        function initThree() {
            renderer = new THREE.WebGLRenderer({ canvas, alpha: false, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            scene = new THREE.Scene();
            // æ·±é‚ƒå¤œç©ºèƒŒæ™¯
            scene.background = new THREE.Color('#020205');
            scene.fog = new THREE.FogExp2(0x020205, 0.05);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 1, 8);

            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            createTree(); // æ„å»ºæ ‘
            
            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const dl = new THREE.DirectionalLight(0xffd700, 2);
            dl.position.set(2, 5, 5);
            scene.add(dl);
        }

        function createTree() {
            // 1. ç²’å­æ ‘å¶
            const count = 4000;
            particleGeo = new THREE.BufferGeometry();
            const pos = [], target = [], color = [], size = [];
            
            const layers = 7;
            for(let i=0; i<count; i++) {
                const layer = Math.floor(Math.random()*layers);
                const h = 3.5;
                const yBase = 1.5 - (layer * 0.6);
                const rBase = 0.1 + (layer * 0.45);
                
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * rBase;
                const y = yBase + (Math.random()-0.5)*0.5;
                
                pos.push(0, -5, 0); // åˆå§‹åœ¨åœ°ä¸‹
                target.push(Math.cos(angle)*r, y, Math.sin(angle)*r);
                
                // é¢œè‰²
                const c = new THREE.Color().setHSL(0.1 + Math.random()*0.05, 1, 0.6);
                color.push(c.r, c.g, c.b);
                size.push(Math.random()*0.15 + 0.05);
            }
            
            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            particleGeo.setAttribute('target', new THREE.Float32BufferAttribute(target, 3)); // æ ‘å½¢æ€ç›®æ ‡
            particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(color, 3));
            particleGeo.setAttribute('size', new THREE.Float32BufferAttribute(size, 1));
            
            // é¢„è®¡ç®—æ–‡å­—å½¢æ€ç›®æ ‡ (å¦‚æœç²’å­ä¸å¤Ÿï¼Œå¾ªç¯ä½¿ç”¨; å¤ªå¤šåˆ™æˆªæ–­)
            const textTargets = createTextTargets(CONFIG.wishText);
            const textAttr = [];
            for(let i=0; i<count; i++) {
                const t = textTargets[i % textTargets.length];
                // éšæœºä¸€ç‚¹åç§»ï¼Œé¿å…é‡å å¤ªæ­»æ¿
                textAttr.push(t.x + (Math.random()-0.5)*0.1, t.y + (Math.random()-0.5)*0.1, t.z);
            }
            particleGeo.setAttribute('textTarget', new THREE.Float32BufferAttribute(textAttr, 3));

            particleMat = new THREE.PointsMaterial({
                map: glowTex, size: 0.1, vertexColors: true,
                blending: THREE.AdditiveBlending, depthWrite: false,
                transparent: true, opacity: 0.9
            });
            
            particles = new THREE.Points(particleGeo, particleMat);
            treeGroup.add(particles);

            // 2. å®ä½“è£…é¥°çƒ
            const orbGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const orbMat = new THREE.MeshStandardMaterial({
                color: 0xffaa00, metalness: 0.9, roughness: 0.1,
                emissive: 0xffaa00, emissiveIntensity: 0.3
            });
            ornaments = new THREE.InstancedMesh(orbGeo, orbMat, 60);
            const dummy = new THREE.Object3D();
            for(let i=0; i<60; i++) {
                dummy.position.set(0, -10, 0); // åˆå§‹éšè—
                dummy.updateMatrix();
                ornaments.setMatrixAt(i, dummy.matrix);
            }
            treeGroup.add(ornaments);
            
            // ä¿å­˜çƒçš„ç›®æ ‡ä½ç½®
            ornaments.userData.targets = [];
            for(let i=0; i<60; i++) {
                const layer = Math.floor(Math.random()*layers);
                const r = 0.2 + (layer * 0.45);
                const angle = Math.random() * Math.PI * 2;
                ornaments.userData.targets.push({
                    x: Math.cos(angle)*r,
                    y: 1.5 - (layer * 0.6) + (Math.random()-0.5)*0.3,
                    z: Math.sin(angle)*r
                });
            }

            // 3. é¡¶éƒ¨æ˜Ÿæ˜Ÿ
            starMesh = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.3, 0),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            starMesh.position.set(0, -10, 0);
            const halo = new THREE.Sprite(new THREE.SpriteMaterial({
                map: glowTex, color: 0xffd700, blending: THREE.AdditiveBlending
            }));
            halo.scale.set(2,2,2);
            starMesh.add(halo);
            treeGroup.add(starMesh);
        }

        // === åŠ¨ç”»é€»è¾‘ ===
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (!state.isExploded) {
                // === æ­£å¸¸ AR æ“æ§æ¨¡å¼ ===
                
                // 1. å¹³æ»‘æ‰‹åŠ¿ä½ç½®
                // æ‰‹ç¦»å¾—è¶Šè¿œ(handSizeå°)ï¼Œæ ‘è¶Šè¿œ(scaleå°/zæ·±)
                // é€»è¾‘åè½¬ï¼šæ‰‹æ”¶å›(å˜å°) -> æ ‘æ‹‰è¿‘(å˜å¤§/zé è¿‘)
                // å‡è®¾ handSize èŒƒå›´ 0.1(è¿œ) ~ 0.3(è¿‘)
                // ç›®æ ‡ï¼šæ‰‹å° -> scaleå¤§
                
                state.currentPos.lerp(state.targetPos, 0.1);
                
                treeGroup.position.x = state.currentPos.x * 5; // å·¦å³ç§»åŠ¨
                treeGroup.position.y = state.currentPos.y * 3; // ä¸Šä¸‹ç§»åŠ¨
                
                // æ—‹è½¬ï¼šéšXç§»åŠ¨è‡ªç„¶æ—‹è½¬
                treeGroup.rotation.y = state.currentPos.x * 2 + time * 0.1;
                
                // ç¼©æ”¾ï¼šç”± "æ‹‰æ‹½" å†³å®š (zå€¼)
                // targetPos.z è¶Šå¤§ä»£è¡¨æ‰‹è¶Šè¿œ(æ‰‹è¶Šå°)ï¼Œæ­¤æ—¶æ ‘åº”è¯¥è¢«â€œæ‹‰å‡ºæ¥â€å˜å¤§
                // map 0.5(æ‰‹å¾ˆå°) -> scale 1.5; 0(æ‰‹å¾ˆå¤§) -> scale 0.5
                let scale = 0.5 + state.targetPos.z * 1.5; 
                scale = Math.max(0.5, Math.min(2.0, scale));
                treeGroup.scale.setScalar(scale);

                // 2. ç²’å­æ±‡èšæˆæ ‘
                const pos = particleGeo.attributes.position.array;
                const target = particleGeo.attributes.target.array;
                
                for(let i=0; i<pos.length; i++) {
                    // ç®€å•çš„å¼¹æ€§è·Ÿéš
                    pos[i] += (target[i] - pos[i]) * 0.05;
                }
                particleGeo.attributes.position.needsUpdate = true;

                // 3. è£…é¥°çƒè·Ÿéš
                const dummy = new THREE.Object3D();
                const oTargets = ornaments.userData.targets;
                for(let i=0; i<60; i++) {
                    const t = oTargets[i];
                    dummy.position.set(t.x, t.y, t.z);
                    // åŠ ä¸Šå‘¼å¸åŠ¨æ•ˆ
                    const s = 1 + Math.sin(time*3 + i)*0.2;
                    dummy.scale.setScalar(s);
                    dummy.updateMatrix();
                    ornaments.setMatrixAt(i, dummy.matrix);
                }
                ornaments.instanceMatrix.needsUpdate = true;

                // 4. æ˜Ÿæ˜Ÿè·Ÿéš
                starMesh.position.lerp(new THREE.Vector3(0, 2.1, 0), 0.05);
                starMesh.rotation.y -= 0.02;

                // 5. éœ‡åŠ¨èƒ½é‡é€»è¾‘
                if(state.handDetected) {
                    if (state.isSpreading && state.handVelocity > CONFIG.shakeThreshold) {
                        state.shakeEnergy += CONFIG.energyGain;
                        instructionEl.innerText = "âš¡ï¸ èƒ½é‡è“„åŠ›ä¸­ï¼ä¿æŒå¼ å¼€å¹¶éœ‡åŠ¨ï¼";
                        instructionEl.style.color = "#ffaa00";
                        // éœ‡åŠ¨ç‰¹æ•ˆï¼šæ ‘èº«æŠ–åŠ¨
                        treeGroup.position.x += (Math.random()-0.5)*0.2;
                    } else {
                        state.shakeEnergy -= CONFIG.energyDecay;
                        instructionEl.innerText = "ğŸ– å¼ å¼€äº”æŒ‡å¹¶å¿«é€Ÿæ‘‡æ™ƒä»¥å¼•çˆ†";
                        instructionEl.style.color = "white";
                    }
                    state.shakeEnergy = Math.max(0, Math.min(1, state.shakeEnergy));
                    
                    // æ›´æ–° UI èƒ½é‡æ¡
                    if(state.shakeEnergy > 0) {
                        energyContainer.style.display = 'block';
                        energyBar.style.width = (state.shakeEnergy * 100) + '%';
                    } else {
                        energyContainer.style.display = 'none';
                    }

                    // è§¦å‘çˆ†ç‚¸ï¼
                    if(state.shakeEnergy >= 1) {
                        triggerExplosion();
                    }
                }

            } else {
                // === çˆ†ç‚¸/æ–‡å­—æ¨¡å¼ ===
                
                // ç²’å­é£å‘æ–‡å­—ç›®æ ‡
                const pos = particleGeo.attributes.position.array;
                const textT = particleGeo.attributes.textTarget.array;
                
                for(let i=0; i<pos.length; i+=3) {
                    // ç›®æ ‡ä½ç½®
                    const tx = textT[i];
                    const ty = textT[i+1];
                    const tz = textT[i+2];
                    
                    // ç¼“åŠ¨é£å‘æ–‡å­—
                    pos[i] += (tx - pos[i]) * 0.04;
                    pos[i+1] += (ty - pos[i+1]) * 0.04;
                    pos[i+2] += (tz - pos[i+2]) * 0.04;
                    
                    // åŠ ä¸€ç‚¹éšæœºæ¼‚æµ®
                    pos[i] += (Math.random()-0.5)*0.005;
                    pos[i+1] += (Math.random()-0.5)*0.005;
                }
                particleGeo.attributes.position.needsUpdate = true;
                
                // æ—‹è½¬æ•´ä¸ªç»„å±•ç¤ºæ–‡å­—
                treeGroup.rotation.y = Math.sin(time*0.5) * 0.1;
                treeGroup.scale.setScalar(1.2); // æ”¾å¤§ä¸€ç‚¹çœ‹æ¸…æ¥š
            }

            renderer.render(scene, camera);
        }

        function triggerExplosion() {
            state.isExploded = true;
            energyContainer.style.display = 'none';
            instructionEl.innerHTML = "âœ¨ " + CONFIG.wishText + " âœ¨";
            
            // éšè—å®ä½“è£…é¥°ï¼Œåªç•™ç²’å­
            ornaments.visible = false;
            starMesh.visible = false;
            
            // ç¬é—´ç‚¸å¼€ä¸€ä¸‹
            const pos = particleGeo.attributes.position.array;
            for(let i=0; i<pos.length; i++) {
                pos[i] += (Math.random()-0.5) * 5; 
            }
            particleGeo.attributes.position.needsUpdate = true;
        }

        // === æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ===
        let lastHandPos = null;

        window.onload = async function() {
            const video = document.getElementById('input-video');
            const loading = document.getElementById('loading');

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.5});
            
            hands.onResults(results => {
                loading.style.display = 'none';
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    state.handDetected = true;
                    const lm = results.multiHandLandmarks[0];
                    
                    // 1. è®¡ç®—æ‰‹æŒä¸­å¿ƒ (ç”¨äºä½ç§»)
                    // 0:è…•, 9:ä¸­æŒ‡æ ¹
                    const cx = lm[9].x; 
                    const cy = lm[9].y;
                    
                    // æ˜ å°„ï¼šx(0~1) -> (-1 ~ 1), y(0~1) -> (1 ~ -1)
                    // æ³¨æ„é•œåƒï¼šMediaPipe x=0æ˜¯å·¦è¾¹(é¢„è§ˆæ˜¯å³è¾¹), x=1æ˜¯å³è¾¹
                    state.targetPos.x = (cx - 0.5) * -3; // åå‘ç§»åŠ¨ç¬¦åˆç›´è§‰
                    state.targetPos.y = (0.5 - cy) * 3;

                    // 2. è®¡ç®—è·ç¦»/æ‹‰æ‹½æ„Ÿ (Zè½´)
                    // æ‰‹æŒå¤§å° (è…•åˆ°ä¸­æŒ‡æ ¹è·ç¦»)
                    const dx = lm[0].x - lm[9].x;
                    const dy = lm[0].y - lm[9].y;
                    const palmSize = Math.sqrt(dx*dx + dy*dy); // çº¦ 0.1(è¿œ) ~ 0.4(è¿‘)
                    
                    // é€»è¾‘ï¼špalmSize å° (è¿œ) -> z å¤§ (æ‹‰è¿‘)
                    // å½’ä¸€åŒ– 0.1~0.4 -> 0~1
                    const distFactor = Math.max(0, Math.min(1, (0.4 - palmSize) / 0.3));
                    state.targetPos.z = distFactor; // 0(æ²¡æ‹‰) ~ 1(æ‹‰æ»¡)

                    // 3. æ£€æµ‹å¼ å¼€äº”æŒ‡
                    // ç®€å•ç®—æ³•ï¼šæŒ‡å°–åˆ°æŒ‡æ ¹è·ç¦» > é˜ˆå€¼
                    // 8:é£ŸæŒ‡å°–, 5:é£ŸæŒ‡æ ¹ ...
                    const tips = [8, 12, 16, 20];
                    const roots = [5, 9, 13, 17];
                    let spreadCount = 0;
                    for(let i=0; i<4; i++) {
                        const d = Math.hypot(lm[tips[i]].x - lm[roots[i]].x, lm[tips[i]].y - lm[roots[i]].y);
                        if(d > 0.08) spreadCount++; // é˜ˆå€¼å¯è°ƒ
                    }
                    // æ‹‡æŒ‡å•ç‹¬ç®—
                    const thumbD = Math.hypot(lm[4].x - lm[17].x, lm[4].y - lm[17].y);
                    if(thumbD > 0.25) spreadCount++;

                    state.isSpreading = spreadCount >= 4;

                    // 4. æ£€æµ‹éœ‡åŠ¨é€Ÿåº¦
                    const now = Date.now();
                    if(lastHandPos) {
                        const dt = (now - lastHandPos.time) / 1000;
                        if(dt > 0) {
                            const dist = Math.hypot(cx - lastHandPos.x, cy - lastHandPos.y);
                            state.handVelocity = dist / dt; // é€Ÿåº¦
                        }
                    }
                    lastHandPos = {x: cx, y: cy, time: now};

                } else {
                    state.handDetected = false;
                    state.shakeEnergy = 0;
                    // æ— æ‰‹æ—¶å›æ­£
                    state.targetPos.set(0, 0, 0); 
                }
            });

            const camera = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            camera.start().catch(e => {
                loading.innerHTML = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·ç¡®ä¿ä½¿ç”¨HTTPS";
            });

            initThree();
            animate();
        };

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
