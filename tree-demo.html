<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Golden AR Tree – Visual Demo</title>
  <style>
    :root {
      --gold: #ffd700;
      --gold-soft: rgba(255, 215, 0, 0.4);
      --night: #050712;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #1b2140 0%, #050712 55%, #020308 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", system-ui, sans-serif;
      color: var(--gold);
    }

    #tree-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .ui-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
      padding: 20px;
    }

    .countdown {
      font-size: 36px;
      font-weight: 800;
      text-shadow: 0 0 18px black;
      margin-top: 8px;
    }

    .hint {
      background: rgba(0, 0, 0, 0.55);
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 14px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      text-align: center;
      box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
    }

    .hint-title {
      font-size: 15px;
      font-weight: 600;
    }

    .hint-sub {
      font-size: 12px;
      opacity: 0.8;
    }

    .bottom-tag {
      font-size: 11px;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <canvas id="tree-canvas"></canvas>

  <div class="ui-overlay">
    <div class="countdown" id="countdown">10s</div>

    <div class="hint">
      <div class="hint-title">✨ 金色圣诞树 Demo</div>
      <div class="hint-sub">自动播放的粒子圣诞树，仅展示视觉效果</div>
      <div class="bottom-tag">后续会接入真正的手势识别和摄像头</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("tree-canvas");
    const ctx = canvas.getContext("2d");
    let w, h, cx, cy;

    function resize() {
      const ratio = window.devicePixelRatio || 1;
      w = canvas.width = window.innerWidth * ratio;
      h = canvas.height = window.innerHeight * ratio;
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      cx = window.innerWidth / 2;
      cy = window.innerHeight * 0.55;
    }
    window.addEventListener("resize", resize);
    resize();

    // -------------------------------
    // 粒子结构：树主体 + 装饰物 + 星星背景
    // -------------------------------

    const foliageParticles = [];
    const ornamentParticles = [];
    const bgStars = [];

    function initFoliage() {
      foliageParticles.length = 0;
      ornamentParticles.length = 0;
      bgStars.length = 0;

      const foliageCount = 2200;  // 树的细碎灯光
      const ornamentCount = 80;   // 较大的装饰物
      const starCount = 180;      // 背景星空

      // 背景星星
      for (let i = 0; i < starCount; i++) {
        bgStars.push({
          x: Math.random() * window.innerWidth,
          y: Math.random() * window.innerHeight,
          r: Math.random() * 1.4 + 0.2,
          baseA: Math.random() * 0.3 + 0.2,
          twinkleSpeed: Math.random() * 1.5 + 0.3
        });
      }

      // 树主体 – 使用圆锥形截面 + 少量噪声
      for (let i = 0; i < foliageCount; i++) {
        const t = Math.random();         // [0,1] 从树顶到树底
        const y = lerp(window.innerHeight * 0.18, window.innerHeight * 0.8, t);

        // 当前层的半宽度（越往上越窄）
        const halfWidth = (1 - Math.pow(t, 1.2)) * window.innerWidth * 0.23;
        const x = cx + (Math.random() * 2 - 1) * halfWidth;

        foliageParticles.push({
          x,
          y,
          baseSize: Math.random() * 1.6 + 0.6,
          phase: Math.random() * Math.PI * 2,
          band: Math.floor(Math.random() * 5), // 大致对应金色缎带的几层
        });
      }

      // 装饰物 – 一些更亮更大的点，随机分布在树内
      for (let i = 0; i < ornamentCount; i++) {
        const t = Math.random() * 0.9;
        const y = lerp(window.innerHeight * 0.2, window.innerHeight * 0.78, t);
        const halfWidth = (1 - Math.pow(t, 1.0)) * window.innerWidth * 0.22;
        const x = cx + (Math.random() * 2 - 1) * halfWidth;

        ornamentParticles.push({
          x,
          y,
          baseSize: Math.random() * 4 + 3,
          hueShift: Math.random() * 20 - 10,
          twinkleSpeed: Math.random() * 2 + 0.5
        });
      }
    }

    function lerp(a, b, t) { return a + (b - a) * t; }

    initFoliage();

    // -------------------------------
    // 绘制函数
    // -------------------------------
    let startTime = performance.now();

    function drawStar(ctx, x, y, radius, spikes) {
      const outerRadius = radius;
      const innerRadius = radius * 0.45;
      let rot = Math.PI / 2 * 3;
      let step = Math.PI / spikes;
      ctx.beginPath();
      ctx.moveTo(x, y - outerRadius);
      for (let i = 0; i < spikes; i++) {
        let lx = x + Math.cos(rot) * outerRadius;
        let ly = y + Math.sin(rot) * outerRadius;
        ctx.lineTo(lx, ly);
        rot += step;

        lx = x + Math.cos(rot) * innerRadius;
        ly = y + Math.sin(rot) * innerRadius;
        ctx.lineTo(lx, ly);
        rot += step;
      }
      ctx.closePath();
    }

    function render(now) {
      const t = (now - startTime) / 1000;

      // 夜空背景
      const grd = ctx.createLinearGradient(0, 0, 0, window.innerHeight);
      grd.addColorStop(0, "#0b1024");
      grd.addColorStop(0.4, "#050712");
      grd.addColorStop(1, "#020308");
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

      // 背景星星
      bgStars.forEach(s => {
        const alpha = s.baseA + Math.sin(t * s.twinkleSpeed) * 0.2;
        ctx.fillStyle = `rgba(255, 240, 200, ${alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      });

      // 底部“能量雾”
      const glowY = window.innerHeight * 0.82;
      const glowRadius = window.innerWidth * 0.35;
      const glowGrad = ctx.createRadialGradient(cx, glowY, 0, cx, glowY, glowRadius);
      glowGrad.addColorStop(0, "rgba(255, 215, 0, 0.7)");
      glowGrad.addColorStop(0.35, "rgba(255, 215, 0, 0.35)");
      glowGrad.addColorStop(1, "rgba(255, 215, 0, 0)");
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(cx, glowY, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      // 树主体粒子
      ctx.save();
      ctx.globalCompositeOperation = "screen";

      foliageParticles.forEach(p => {
        const bandOffset = Math.sin(t * 1.2 + p.band) * 6;
        const flicker = 0.6 + Math.sin(p.phase + t * 2.2) * 0.4;
        const size = p.baseSize * (0.7 + flicker * 0.7);

        ctx.fillStyle = `rgba(255, 230, 150, ${0.15 + flicker * 0.4})`;
        ctx.beginPath();
        ctx.arc(p.x + bandOffset, p.y, size, 0, Math.PI * 2);
        ctx.fill();
      });

      // 装饰物
      ornamentParticles.forEach(p => {
        const twinkle = 0.5 + Math.sin(t * p.twinkleSpeed) * 0.5;
        const size = p.baseSize * (0.8 + twinkle * 0.6);
        const alpha = 0.5 + twinkle * 0.5;

        ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
        ctx.fill();
      });

      // 顶部金色星星
      const starY = window.innerHeight * 0.18;
      const starPulse = 1 + Math.sin(t * 3) * 0.08;
      ctx.fillStyle = "rgba(255, 220, 150, 0.95)";
      ctx.shadowColor = "rgba(255, 220, 150, 0.9)";
      ctx.shadowBlur = 25;
      drawStar(ctx, cx, starY, 18 * starPulse, 5);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // 简单的倒计时（只是视觉上的，不控制动画）
    let left = 10;
    const countdownEl = document.getElementById("countdown");
    const timer = setInterval(() => {
      left--;
      if (left <= 0) {
        clearInterval(timer);
        countdownEl.innerText = "0s";
      } else {
        countdownEl.innerText = left + "s";
      }
    }, 1000);
  </script>
</body>
</html>
