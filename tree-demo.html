<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Luxury Golden AR Tree</title>
    
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* 1. ç›®æ ‡è§†è§‰é£æ ¼ï¼šæ·±è‰²å¤œç©ºèƒŒæ™¯ */
            background: radial-gradient(circle at 50% 100%, #1a1200 0%, #050505 60%, #000 100%);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: #ffd700;
        }

        /* è§†é¢‘é¢„è§ˆå°çª—å£ (å³ä¸Šè§’) */
        #input-video {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 100px;
            height: auto;
            aspect-ratio: 3/4;
            object-fit: cover;
            border-radius: 12px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            transform: scaleX(-1);
            z-index: 20;
            background: #000;
        }

        /* ä¸» Canvasï¼Œç”¨äº Three.js æ¸²æŸ“ */
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* é¡¶éƒ¨å€’è®¡æ—¶ */
        #timer {
            margin-top: 30px;
            font-size: 48px;
            font-weight: 800;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        /* æç¤ºæ–‡å­— */
        #instruction {
            margin-top: 15px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            border: 1px solid rgba(255,215,0,0.2);
        }

        /* æœ€ç»ˆç¥ç¦æ–‡å­— */
        #final-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255, 165, 0, 1);
            opacity: 0;
            transition: opacity 1s ease-in;
            text-align: center;
            width: 90%;
            z-index: 30;
        }

        /* åŠ è½½é®ç½© */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050505;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffd700;
            font-size: 16px;
            flex-direction: column;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,215,0,0.3);
            border-top: 3px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>
    <canvas id="three-canvas"></canvas>

    <div id="ui-layer">
        <div id="timer">12</div>
        <div id="instruction">
            ğŸ– ä¼¸æ‰‹æ§åˆ¶ AR åœ£è¯æ ‘<br>
            <span style="font-size:12px; opacity:0.8">èšåˆä¸­... è¯·ç¨å€™</span>
        </div>
        <div id="final-message">âœ¨ é—ºèœœä»Šå¹´åœ£è¯ä¸€èµ·æš´å¯Œï¼âœ¨</div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div>å¯åŠ¨é‡‘è‰² AR å¼•æ“ä¸­...</div>
    </div>

    <script>
        // === å…¨å±€çŠ¶æ€ ===
        const state = {
            targetAngle: 0, 
            currentAngle: 0,
            targetScale: 1,
            currentScale: 1,
            isExploded: false,
            timeLeft: 12,
            handDetected: false,
            
            // åŠ¨ç”»çŠ¶æ€æœºï¼š0=CHAOS(æ··æ²Œ), 1=FORMING(èšåˆä¸­), 2=FORMED(æˆå‹å¯æ§)
            animPhase: 0, 
            startTime: Date.now()
        };

        const canvas = document.getElementById('three-canvas');
        const timerElement = document.getElementById('timer');
        const msgElement = document.getElementById('final-message');
        const instructionEl = document.getElementById('instruction');

        // === Three.js åœºæ™¯å˜é‡ ===
        let scene, camera, renderer;
        let treeGroup; // åŒ…å«æ•´ä¸ªæ ‘çš„å®¹å™¨
        let particlesGeometry; // å­˜å‚¨ç²’å­ä½ç½®ç”¨äºåŠ¨ç”»
        let particlesMaterial;
        let starSprite;

        // ç”Ÿæˆå‘å…‰çº¹ç† (æ¨¡æ‹Ÿ Bloom æ•ˆæœ)
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.2, 'rgba(255, 215, 0, 0.8)');
            grad.addColorStop(0.5, 'rgba(255, 140, 0, 0.2)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        const glowTexture = createGlowTexture();

        // === åˆå§‹åŒ– Three.js åœºæ™¯ ===
        function initThree() {
            // æ¸²æŸ“å™¨ï¼šå¼€å¯é€æ˜èƒŒæ™¯
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // å®Œå…¨é€æ˜ï¼Œé€å‡º CSS çš„å¤œç©ºèƒŒæ™¯

            scene = new THREE.Scene();

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0.5, 6); // ç¨å¾®æ”¾ä½è§†è§’ï¼Œä»°è§†æ ‘

            // åˆ›å»ºæ ‘çš„ç»„
            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            // æ„å»ºå¥¢åç²’å­æ ‘
            buildLuxuryTree();
            
            // ç›‘å¬çª—å£å¤§å°
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // === æ„å»ºæ ‘ä½“ (Chaos -> Formed é€»è¾‘) ===
        function buildLuxuryTree() {
            // ç²’å­æ€»æ•°
            const particleCount = 4000;
            particlesGeometry = new THREE.BufferGeometry();
            
            const positions = [];       // å½“å‰ä½ç½®
            const targetPositions = []; // æ ‘çš„ç›®æ ‡ä½ç½® (FORMED)
            const chaosPositions = [];  // åˆå§‹éšæœºä½ç½® (CHAOS)
            const colors = [];
            const sizes = [];

            const colorPalette = [
                new THREE.Color('#FFD700'), // çº¯é‡‘
                new THREE.Color('#FFF8DC'), // ç‰ç±³ä¸è‰²(é«˜å…‰)
                new THREE.Color('#DAA520'), // é‡‘éº’éºŸè‰²(æš—éƒ¨)
            ];

            // æ ‘çš„å½¢çŠ¶å‚æ•°
            const treeHeight = 3.5;
            const treeRadiusBase = 1.4;

            for (let i = 0; i < particleCount; i++) {
                // 1. ç”Ÿæˆæ ‘å½¢ç›®æ ‡ä½ç½® (åœ†é”¥ä½“åˆ†å¸ƒ)
                // y: -1.5 åˆ° +2.0
                const p = Math.random();
                const y = -1.5 + p * treeHeight;
                // åŠå¾„éšé«˜åº¦å˜å°
                const r = (1 - p) * treeRadiusBase; 
                // èºæ—‹åˆ†å¸ƒ + éšæœºæŠ–åŠ¨ = è‡ªç„¶æ¾é’ˆæ„Ÿ
                const angle = i * 0.1 + Math.random() * Math.PI * 2;
                // å¡«å……åœ†é”¥å†…éƒ¨
                const radius = Math.random() * r; 
                
                const tx = Math.cos(angle) * radius;
                const tz = Math.sin(angle) * radius;
                const ty = y;

                targetPositions.push(tx, ty, tz);

                // 2. ç”Ÿæˆæ··æ²Œåˆå§‹ä½ç½® (æ•£è½åœ¨å±å¹•å¤–æˆ–å‘¨å›´)
                const cx = (Math.random() - 0.5) * 15;
                const cy = (Math.random() - 0.5) * 15;
                const cz = (Math.random() - 0.5) * 10;
                chaosPositions.push(cx, cy, cz);
                
                // åˆå§‹ä½ç½®è®¾ä¸ºæ··æ²Œ
                positions.push(cx, cy, cz);

                // 3. é¢œè‰²å’Œå¤§å°
                const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                colors.push(color.r, color.g, color.b);

                // å¶å°”æœ‰ä¸€äº›å¤§ä¸€ç‚¹çš„ç²’å­ä½œä¸ºâ€œé‡‘çƒâ€
                if (Math.random() > 0.95) {
                    sizes.push(0.15 + Math.random() * 0.1); // è£…é¥°ç‰©
                } else {
                    sizes.push(0.04 + Math.random() * 0.04); // é‡‘ç²‰/å¶å­
                }
            }

            particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('targetPos', new THREE.Float32BufferAttribute(targetPositions, 3));
            particlesGeometry.setAttribute('chaosPos', new THREE.Float32BufferAttribute(chaosPositions, 3));
            particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            particlesGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // æè´¨ï¼šä½¿ç”¨ AdditiveBlending å®ç°å‘å…‰æ•ˆæœ
            particlesMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                map: glowTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            // ShaderMaterial ä¼šæ›´å¥½ï¼Œä½†ä¸ºäº†ä¿æŒå•æ–‡ä»¶ç®€æ´ï¼Œè¿™é‡Œç”¨ Points + sizeç¼©æ”¾é€»è¾‘
            // ä¸ºäº†è®© size å±æ€§ç”Ÿæ•ˆï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹ä¸€ä¸‹ PointsMaterial (å¯é€‰ï¼Œè¿™é‡Œç›´æ¥ç”¨ç»Ÿä¸€sizeç®€å•å¤„ç†ï¼Œæˆ–è€…ç”¨Shader)
            // ä¸ºäº†ç®€å•èµ·è§ï¼Œè¿™é‡Œç›´æ¥åˆ›å»º Points
            const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            treeGroup.add(particleSystem);

            // æ·»åŠ é¡¶éƒ¨æ˜Ÿæ˜Ÿ (Sprite)
            const starMaterial = new THREE.SpriteMaterial({ 
                map: glowTexture, 
                color: 0xffffee, 
                blending: THREE.AdditiveBlending 
            });
            starSprite = new THREE.Sprite(starMaterial);
            starSprite.position.set(0, 2.1, 0); // æ ‘é¡¶
            starSprite.scale.set(0, 0, 0); // åˆå§‹éšè—
            treeGroup.add(starSprite);
            
            // æ·»åŠ ä¸€ä¸ªç‚¹å…‰æºå¢å¼ºç«‹ä½“æ„Ÿ
            const pointLight = new THREE.PointLight(0xffd700, 2, 10);
            pointLight.position.set(0, 1, 2);
            treeGroup.add(pointLight);
        }

        // === åŠ¨ç”»å¾ªç¯ ===
        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const elapsed = (now - state.startTime) / 1000; // ç§’

            // 1. çŠ¶æ€æœºé€»è¾‘ï¼šChaos -> Formed
            if (!state.isExploded) {
                // 0~3ç§’ï¼šèšåˆè¿‡ç¨‹
                if (elapsed < 3) {
                    state.animPhase = 1;
                    const progress = elapsed / 3; 
                    // ç¼“åŠ¨å‡½æ•° easeOutCubic
                    const t = 1 - Math.pow(1 - progress, 3);
                    
                    updateParticlesPosition(t);
                    
                    // æ˜Ÿæ˜Ÿæ…¢æ…¢å˜å¤§
                    const starScale = t * 0.8;
                    starSprite.scale.set(starScale, starScale, starScale);
                    
                    instructionEl.innerHTML = `âœ¨ é‡‘è‰²ç²’å­èšåˆä¸­... ${(progress*100).toFixed(0)}%`;
                } 
                // 3ç§’åï¼šæˆå‹ï¼Œå…è®¸æ§åˆ¶
                else {
                    if (state.animPhase === 1) {
                        state.animPhase = 2;
                        instructionEl.innerHTML = `ğŸ‘‹ å·¦å³ç§»åŠ¨æ—‹è½¬ Â· å‰åç§»åŠ¨ç¼©æ”¾`;
                    }
                    
                    // æŒç»­çš„å¾®å°å‘¼å¸åŠ¨ç”»
                    const breathe = Math.sin(now * 0.002) * 0.05;
                    
                    // æ‰‹åŠ¿æ§åˆ¶æ’å€¼
                    const lerpSpeed = 0.1;
                    state.currentAngle += (state.targetAngle - state.currentAngle) * lerpSpeed;
                    state.currentScale += (state.targetScale - state.currentScale) * lerpSpeed;

                    // åº”ç”¨å˜æ¢
                    treeGroup.rotation.y = state.currentAngle + (now * 0.0005); // å åŠ ä¸€ç‚¹ç‚¹è‡ªè½¬
                    const s = state.currentScale + breathe;
                    treeGroup.scale.set(s, s, s);
                    
                    // æ˜Ÿæ˜Ÿé—ªçƒ
                    starSprite.material.opacity = 0.7 + 0.3 * Math.sin(now * 0.005);
                }
            } else {
                // çˆ†ç‚¸åé€»è¾‘
                updateExplosion();
            }

            renderer.render(scene, camera);
        }

        // æ›´æ–°ç²’å­ä½ç½® (Lerp: Chaos -> Target)
        function updateParticlesPosition(t) {
            const positions = particlesGeometry.attributes.position.array;
            const targets = particlesGeometry.attributes.targetPos.array;
            const chaos = particlesGeometry.attributes.chaosPos.array;
            
            for (let i = 0; i < positions.length; i++) {
                // pos = chaos + (target - chaos) * t
                positions[i] = chaos[i] + (targets[i] - chaos[i]) * t;
            }
            particlesGeometry.attributes.position.needsUpdate = true;
        }

        // çˆ†ç‚¸åŠ¨ç”»é€»è¾‘ (ç®€å•çš„å‘å¤–é£æ•£)
        function explodeTree() {
            state.isExploded = true;
            timerElement.style.display = 'none';
            instructionEl.style.display = 'none';
            
            // è®°å½•å½“å‰ä½ç½®ä½œä¸ºçˆ†ç‚¸èµ·ç‚¹
            const positions = particlesGeometry.attributes.position.array;
            // ä¸ºæ¯ä¸ªç²’å­ç”Ÿæˆéšæœºé€Ÿåº¦å‘é‡
            particlesGeometry.userData.velocities = [];
            for(let i=0; i < positions.length / 3; i++) {
                const vx = (Math.random() - 0.5) * 0.5;
                const vy = (Math.random() - 0.5) * 0.5;
                const vz = (Math.random() - 0.5) * 0.5;
                particlesGeometry.userData.velocities.push(vx, vy, vz);
            }
            
            // æ˜¾ç¤ºç¥ç¦è¯­
            msgElement.style.opacity = 1;
            setTimeout(() => { msgElement.style.opacity = 0; }, 4000);
        }

        function updateExplosion() {
            const positions = particlesGeometry.attributes.position.array;
            const vels = particlesGeometry.userData.velocities;
            
            if (!vels) return;

            for(let i=0; i < positions.length / 3; i++) {
                positions[i*3] += vels[i*3];     // x
                positions[i*3+1] += vels[i*3+1]; // y
                positions[i*3+2] += vels[i*3+2]; // z
                
                // åŠ ä¸€ç‚¹é‡åŠ›
                vels[i*3+1] -= 0.005;
            }
            particlesGeometry.attributes.position.needsUpdate = true;
            
            // æ…¢æ…¢æ¶ˆå¤±
            if (particlesMaterial.opacity > 0) {
                particlesMaterial.opacity -= 0.01;
            }
        }

        // === åº”ç”¨å¯åŠ¨é€»è¾‘ ===
        window.onload = async function() {
            initThree();
            animate(); // å¯åŠ¨æ¸²æŸ“å¾ªç¯

            const videoElement = document.getElementById('input-video');
            const loadingElement = document.getElementById('loading');
            const timerElement = document.getElementById('timer');

            // åˆå§‹åŒ– MediaPipe
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            try {
                await cameraUtils.start();
                loadingElement.style.display = 'none'; 
                startCountdown(); 
            } catch (err) {
                console.error(err);
                loadingElement.innerHTML = "<div>æ— æ³•å¼€å¯æ‘„åƒå¤´</div><div style='font-size:14px; opacity:0.7'>è¯·ä½¿ç”¨ HTTPS</div>";
            }

            // MediaPipe æ‰‹åŠ¿å¤„ç†
            function onResults(results) {
                if (state.animPhase < 2) return; // è¿˜æ²¡èšåˆå®Œï¼Œä¸å“åº”æ‰‹åŠ¿

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    state.handDetected = true;
                    const landmarks = results.multiHandLandmarks[0];

                    // X åæ ‡ -> æ—‹è½¬ (-60 ~ +60åº¦ -> -1 ~ 1 å¼§åº¦)
                    const palmX = landmarks[9].x; 
                    state.targetAngle = (palmX - 0.5) * 2.5;

                    // è·ç¦» -> ç¼©æ”¾
                    const dx = landmarks[0].x - landmarks[9].x;
                    const dy = landmarks[0].y - landmarks[9].y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    const scaleFactor = Math.min(Math.max(distance * 4, 0.7), 1.4);
                    state.targetScale = scaleFactor;
                } else {
                    state.handDetected = false;
                    // æ— æ‰‹æ—¶ç¼“æ…¢å›æ­£
                    state.targetAngle = 0;
                    state.targetScale = 1;
                }
            }

            function startCountdown() {
                const timerId = setInterval(() => {
                    if (state.timeLeft > 0) {
                        state.timeLeft--;
                        timerElement.innerText = state.timeLeft;
                    } else {
                        clearInterval(timerId);
                        explodeTree();
                    }
                }, 1000);
            }
        };
    </script>
</body>
</html>
