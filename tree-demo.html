<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Golden AR Christmas Tree - Deluxe Edition</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* æ·±è‰²å¤œç©ºèƒŒæ™¯ï¼Œé…åˆé‡‘è‰²å…‰æ™• */
            background: radial-gradient(circle at 50% 100%, #1a1200 0%, #050505 60%, #000 100%);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            color: #ffd700;
        }

        /* è§†é¢‘é¢„è§ˆå°çª—å£ (å³ä¸Šè§’) */
        #input-video {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 100px;
            height: auto;
            aspect-ratio: 3/4;
            object-fit: cover;
            border-radius: 12px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            transform: scaleX(-1);
            z-index: 20;
            background: #000;
        }

        /* ä¸» Canvasï¼Œç”¨äºç»˜åˆ¶åœ£è¯æ ‘å’Œç²’å­ */
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* é¡¶éƒ¨å€’è®¡æ—¶ */
        #timer {
            margin-top: 30px;
            font-size: 48px;
            font-weight: 800;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        /* æç¤ºæ–‡å­— */
        #instruction {
            margin-top: 15px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            text-align: center;
            border: 1px solid rgba(255,215,0,0.2);
        }

        /* æœ€ç»ˆç¥ç¦æ–‡å­— */
        #final-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255, 165, 0, 1);
            opacity: 0;
            transition: opacity 1s ease-in;
            text-align: center;
            width: 90%;
            z-index: 30;
        }

        /* åŠ è½½é®ç½© */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050505;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffd700;
            font-size: 16px;
            flex-direction: column;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,215,0,0.3);
            border-top: 3px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>

    <canvas id="main-canvas"></canvas>

    <div id="ui-layer">
        <div id="timer">12</div>
        <div id="instruction">
            ğŸ‘‹ ä¼¸æ‰‹å³å¯æ§åˆ¶<br>
            <span style="font-size:12px; opacity:0.8">å·¦å³ç§»åŠ¨æ—‹è½¬ Â· å‰åç§»åŠ¨ç¼©æ”¾</span>
        </div>
        <div id="final-message">âœ¨ é—ºèœœä»Šå¹´åœ£è¯ä¸€èµ·æš´å¯Œï¼âœ¨</div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div>å¯åŠ¨ AR å¼•æ“ä¸­...</div>
    </div>

    <script>
        // å…¨å±€çŠ¶æ€
        const state = {
            targetAngle: 0,    // ç›®æ ‡æ—‹è½¬è§’åº¦ (å¼§åº¦)
            currentAngle: 0,   // å½“å‰æ—‹è½¬è§’åº¦ (å¹³æ»‘æ’å€¼ç”¨)
            targetScale: 1,    // ç›®æ ‡ç¼©æ”¾
            currentScale: 1,   // å½“å‰ç¼©æ”¾
            isExploded: false,
            timeLeft: 12,
            handDetected: false,
            particles: []      // çˆ†ç‚¸ç²’å­æ•°ç»„
        };

        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const timerElement = document.getElementById('timer');
        const msgElement = document.getElementById('final-message');

        // è®¾ç½® Canvas å°ºå¯¸
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // ==========================================
        // æ ¸å¿ƒç»˜åˆ¶å‡½æ•°ï¼šç²¾è‡´çš„é‡‘è‰²åœ£è¯æ ‘
        // (æ›¿æ¢äº†åŸæœ‰çš„ç®€å•ä¸‰è§’å½¢ç»˜åˆ¶)
        // ==========================================
        function drawGoldenTree(ctx, width, height, t = 0, angle = 0, scale = 1) {
            
            // å¦‚æœå·²ç»çˆ†ç‚¸ï¼Œåªç»˜åˆ¶ç²’å­ï¼Œä¸ç”»æ ‘
            if (state.isExploded) {
                drawExplosion(ctx, width, height);
                return;
            }

            ctx.clearRect(0, 0, width, height);

            const cx = width / 2;
            // æ ‘çš„åŸºç¡€ä½ç½®ï¼Œåº”ç”¨ç¼©æ”¾
            // æ ‘çš„é«˜åº¦åŸºå‡†
            const treeBaseH = height * 0.65; 
            const treeHeight = treeBaseH * scale; 
            const baseY = height * 0.85; // æ ‘åº•ä½ç½®
            
            const time = t * 0.001; // ç§’

            // ----- 1. èƒŒæ™¯æ˜Ÿå…‰è½»å¾®é‡‘é›¾ (è·Ÿéšæ ‘çš„å¤§å°å˜åŒ–ä¸€ç‚¹ç‚¹) -----
            const bgRadius = treeHeight * 0.9;
            const bgGrad = ctx.createRadialGradient(
                cx, baseY - treeHeight * 0.4, treeHeight * 0.1,
                cx, baseY - treeHeight * 0.4, bgRadius
            );
            bgGrad.addColorStop(0, "rgba(255, 215, 0, 0.12)");
            bgGrad.addColorStop(0.4, "rgba(255, 215, 0, 0.02)");
            bgGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // æ¨¡æ‹Ÿ 3D æ—‹è½¬çš„ç³»æ•° (sin/cos)
            // è¿™é‡Œçš„ angle ä¸»è¦ç”¨æ¥æ§åˆ¶æ ‘èº«è£…é¥°ç‰©çš„æ¨ªå‘åç§»ï¼Œæ¨¡æ‹Ÿæ—‹è½¬è§†è§‰
            const rotSin = Math.sin(angle);
            const rotCos = Math.cos(angle);

            // ----- 2. åˆ†å±‚é‡‘è‰²æ ‘èº« -----
            const layerCount = 7;
            for (let i = 0; i < layerCount; i++) {
                const progress = i / (layerCount - 1); // 0~1 (0æ˜¯åº•, 1æ˜¯é¡¶)
                
                // è®¡ç®—æ¯ä¸€å±‚çš„é¡¶éƒ¨å’Œåº•éƒ¨ Y åæ ‡
                // æ³¨æ„ï¼šè¿™é‡Œè¦ä¹˜ scale
                const layerYTop = baseY - treeHeight * (1 - progress * 0.9);
                const layerYBottom = baseY - treeHeight * (1 - (progress + 0.18));
                
                // æ¯ä¸€å±‚çš„å®½åº¦ (åŠå®½)
                const baseHalfWidth = (1 - progress * 0.9) * (width * 0.25);
                const halfWidth = baseHalfWidth * scale;

                // è½»å¾®å·¦å³æ‘†åŠ¨ï¼ˆå‘¼å¸æ„Ÿï¼‰ï¼Œè¶Šä¸Šé¢æ‘†åŠ¨è¶Šå¤§
                const sway = Math.sin(time * 1.5 + progress * 3) * (5 * (1 - progress));
                
                // æ¨¡æ‹Ÿæ—‹è½¬é€è§†ï¼šå®½åº¦éšæ—‹è½¬è§’åº¦å¾®å¾®å˜åŒ– (å¯é€‰ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†åªå˜åç§»)
                const leftX = cx - halfWidth + sway;
                const rightX = cx + halfWidth + sway;

                const grad = ctx.createLinearGradient(cx, layerYTop, cx, layerYBottom);
                grad.addColorStop(0, "rgba(255, 255, 210, 0.95)");
                grad.addColorStop(0.3, "rgba(255, 230, 150, 0.95)");
                grad.addColorStop(0.7, "rgba(255, 210, 80, 0.9)");
                grad.addColorStop(1, "rgba(200, 140, 20, 0.9)");

                ctx.save();
                ctx.shadowColor = "rgba(255, 215, 0, 0.8)";
                ctx.shadowBlur = 25 * scale;
                ctx.beginPath();
                // è´å¡å°”æ›²çº¿ç»˜åˆ¶æŸ”å’Œçš„ä¸‰è§’å½¢å±‚
                ctx.moveTo(cx + sway * 0.5, layerYTop);
                ctx.quadraticCurveTo(
                    cx - halfWidth * 0.2 + sway * 0.2,
                    (layerYTop + layerYBottom) / 2,
                    leftX,
                    layerYBottom
                );
                ctx.lineTo(rightX, layerYBottom);
                ctx.quadraticCurveTo(
                    cx + halfWidth * 0.2 + sway * 0.2,
                    (layerYTop + layerYBottom) / 2,
                    cx + sway * 0.5,
                    layerYTop
                );
                ctx.closePath();
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.restore();
            }

            // ----- 3. é‡‘è‰²è£…é¥°å¸¦ï¼ˆä¸å¸¦ï¼‰ -----
            // ä¸å¸¦ä¹Ÿéœ€è¦è·Ÿéšæ—‹è½¬äº§ç”Ÿä½ç§»
            ctx.save();
            ctx.lineWidth = 3 * scale;
            ctx.shadowColor = "rgba(255, 255, 200, 0.9)";
            ctx.shadowBlur = 15;
            const bandCount = 3;
            for (let i = 0; i < bandCount; i++) {
                const p = 0.25 + i * 0.18;
                const y = baseY - treeHeight * p;
                const bandW = width * (0.25 + (0.16 - i * 0.02)) * scale;
                
                // ä¸å¸¦çš„ X åç§»éšæ—‹è½¬å˜åŒ–
                const bandOffset = rotSin * bandW * 0.3;

                ctx.strokeStyle = "rgba(255, 240, 180, 0.95)";
                ctx.beginPath();
                ctx.moveTo(cx - bandW + bandOffset, y);
                ctx.quadraticCurveTo(
                    cx + Math.sin(time * 1.2 + i) * 30 + bandOffset,
                    y + 10 * Math.sin(time * 2 + i) * scale,
                    cx + bandW + bandOffset,
                    y + 5 * scale
                );
                ctx.stroke();
            }
            ctx.restore();

            // ----- 4. é‡‘å¸ / å…ƒå® / å®çŸ³è£…é¥° -----
            // è£…é¥°ç‰©æ•°ç»„
            const ornaments = [
                { x: -0.16, y: 0.40, type: "coin" },
                { x: 0.18, y: 0.42, type: "gem" },
                { x: -0.24, y: 0.55, type: "ingot" },
                { x: 0.22, y: 0.62, type: "coin" },
                { x: -0.12, y: 0.70, type: "gem" },
                { x: 0.08, y: 0.32, type: "ingot" },
                { x: 0.0, y: 0.48, type: "coin" },
                { x: -0.10, y: 0.85, type: "coin" }, 
                { x: 0.10, y: 0.78, type: "gem" }
            ];

            ornaments.forEach((o, idx) => {
                // è®¡ç®—æ—‹è½¬åçš„ X åæ ‡
                // ç®€å•çš„ 3D æ—‹è½¬æ¨¡æ‹Ÿï¼šx' = x * cos(angle)
                // è¿™é‡Œæˆ‘ä»¬å‡è®¾æ ‘æ˜¯åœ†é”¥ä½“ï¼Œè£…é¥°ç‰©è´´åœ¨è¡¨é¢
                // åŸå§‹ x æ˜¯å½’ä¸€åŒ–å®½åº¦ï¼Œæˆ‘ä»¬éœ€è¦è½¬æ¢æˆå®é™…åƒç´ ä½ç½®
                // è¿™é‡Œçš„ o.x æ˜¯ç›¸å¯¹äºæ ‘å®½åº¦çš„æ¯”ä¾‹
                
                // ç®€åŒ–çš„æ—‹è½¬é€»è¾‘ï¼šè®©å®ƒä»¬å·¦å³ç§»åŠ¨ï¼Œæ¨¡æ‹Ÿæ—‹è½¬
                // å¦‚æœè½¬åˆ°äº†èƒŒé¢ (z < 0)ï¼Œå°±ä¸ç»˜åˆ¶æˆ–è€…å˜æš—
                // è¿™é‡Œç”¨ä¸€ä¸ªç®€å•çš„ç›¸ä½åç§»æ¥æ¨¡æ‹Ÿåœ†å‘¨è¿åŠ¨
                
                const originalAngle = o.x * Math.PI * 4; // å‡å®šåˆå§‹è§’åº¦
                const currentOrbit = originalAngle + angle; // åŠ ä¸Šæ‰‹åŠ¿æ—‹è½¬è§’
                
                // è®¡ç®—é€è§†åçš„ X ä½ç½®
                // è¿™é‡Œçš„ 0.25 æ˜¯æ ‘åº•åŠå¾„çš„å¤§è‡´æ¯”ä¾‹ç³»æ•°
                const orbitRadius = width * 0.25 * (1 - o.y * 0.8) * scale; 
                const finalX = cx + Math.sin(currentOrbit) * orbitRadius;
                const finalY = baseY - treeHeight * o.y;

                // ç®€å•çš„é®æŒ¡å‰”é™¤ï¼šå¦‚æœåœ¨èƒŒé¢ (cos < 0)ï¼Œåˆ™ä¸ç»˜åˆ¶
                if (Math.cos(currentOrbit) < -0.2) return;

                const pulse = (1 + 0.15 * Math.sin(time * 3 + idx)) * scale;
                
                ctx.save();
                ctx.translate(finalX, finalY);
                ctx.scale(pulse, pulse);
                ctx.shadowColor = "rgba(255, 215, 0, 1)";
                ctx.shadowBlur = 18;

                if (o.type === "coin") {
                    const r = 7;
                    const coinGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                    coinGrad.addColorStop(0, "#fff8d0");
                    coinGrad.addColorStop(0.4, "#ffe58a");
                    coinGrad.addColorStop(1, "#d79b1f");
                    ctx.fillStyle = coinGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.fill();
                } else if (o.type === "ingot") {
                    ctx.fillStyle = "#ffd700";
                    ctx.beginPath();
                    ctx.moveTo(-10, 4);
                    ctx.lineTo(0, -6);
                    ctx.lineTo(10, 4);
                    ctx.quadraticCurveTo(0, 10, -10, 4);
                    ctx.closePath();
                    ctx.fill();
                } else if (o.type === "gem") {
                    ctx.fillStyle = "#fff2b0";
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(7, 0);
                    ctx.lineTo(0, 8);
                    ctx.lineTo(-7, 0);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
            });

            // ----- 5. é¡¶éƒ¨å‘å…‰æ˜Ÿæ˜Ÿ -----
            const starY = baseY - treeHeight * 1.02;
            const starR = 14 * scale;
            ctx.save();
            ctx.translate(cx, starY);
            ctx.rotate(Math.sin(time * 1.5) * 0.15 + angle * 0.5); // æ˜Ÿæ˜Ÿä¹Ÿç¨å¾®è·Ÿç€è½¬ä¸€ç‚¹
            ctx.shadowColor = "rgba(255, 255, 200, 1)";
            ctx.shadowBlur = 25;
            const starGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, starR * 1.4);
            starGrad.addColorStop(0, "#fffbe5");
            starGrad.addColorStop(0.5, "#ffe07a");
            starGrad.addColorStop(1, "rgba(255, 215, 0, 0)");
            ctx.fillStyle = starGrad;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const a = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                const x1 = Math.cos(a) * starR;
                const y1 = Math.sin(a) * starR;
                const x2 = Math.cos(a + Math.PI / 5) * (starR / 2.2);
                const y2 = Math.sin(a + Math.PI / 5) * (starR / 2.2);
                if (i === 0) ctx.moveTo(x1, y1);
                else ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ==========================================
        // ç²’å­çˆ†ç‚¸æ•ˆæœ
        // ==========================================
        function initExplosion(cx, cy) {
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 2;
                state.particles.push({
                    x: cx,
                    y: cy,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    alpha: 1,
                    size: Math.random() * 5 + 2,
                    color: `hsl(${40 + Math.random() * 20}, 100%, 70%)` // é‡‘è‰²ç³»
                });
            }
        }

        function drawExplosion(ctx, width, height) {
            ctx.clearRect(0, 0, width, height); // æ¸…ç©ºç”»å¸ƒ
            
            // æ›´æ–°å¹¶ç»˜åˆ¶ç²’å­
            for (let i = 0; i < state.particles.length; i++) {
                const p = state.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.1; // é‡åŠ›
                p.alpha -= 0.015; // æ·¡å‡º

                if (p.alpha > 0) {
                    ctx.save();
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = p.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        // ==========================================
        // åº”ç”¨é€»è¾‘ & åŠ¨ç”»å¾ªç¯
        // ==========================================
        window.onload = async function() {
            const videoElement = document.getElementById('input-video');
            const loadingElement = document.getElementById('loading');

            // 1. åˆå§‹åŒ– MediaPipe Hands
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            // 2. å¯åŠ¨æ‘„åƒå¤´
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            try {
                await cameraUtils.start();
                loadingElement.style.display = 'none'; 
                startCountdown(); 
            } catch (err) {
                console.error(err);
                loadingElement.innerHTML = "<div>æ— æ³•å¼€å¯æ‘„åƒå¤´</div><div style='font-size:14px; margin-top:10px; opacity:0.7'>è¯·ç¡®ä¿ä½¿ç”¨HTTPSæˆ–æœ¬åœ°ç¯å¢ƒ</div>";
            }

            // 3. æ‰‹åŠ¿å¤„ç†å›è°ƒ
            function onResults(results) {
                if (state.isExploded) return;

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    state.handDetected = true;
                    const landmarks = results.multiHandLandmarks[0];

                    // X åæ ‡æ§åˆ¶æ—‹è½¬
                    // 0 (å·¦) -> 1 (å³)
                    const palmX = landmarks[9].x; 
                    // æ˜ å°„åˆ°è§’åº¦: -1.5 ~ 1.5 (çº¦ +-85åº¦)
                    state.targetAngle = (palmX - 0.5) * 3;

                    // è·ç¦»æ§åˆ¶ç¼©æ”¾
                    // è®¡ç®—æ‰‹æŒå¤§å°
                    const dx = landmarks[0].x - landmarks[9].x;
                    const dy = landmarks[0].y - landmarks[9].y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // æ˜ å°„ç¼©æ”¾
                    const scaleFactor = Math.min(Math.max(distance * 4, 0.7), 1.5);
                    state.targetScale = scaleFactor;

                } else {
                    state.handDetected = false;
                    // æ— æ‰‹æ—¶å¤ä½
                    state.targetAngle = 0;
                    state.targetScale = 1;
                }
            }

            // 4. å€’è®¡æ—¶
            function startCountdown() {
                const timerId = setInterval(() => {
                    state.timeLeft--;
                    timerElement.innerText = state.timeLeft;

                    if (state.timeLeft <= 0) {
                        clearInterval(timerId);
                        triggerExplosion();
                    }
                }, 1000);
            }

            // 5. è§¦å‘çˆ†ç‚¸
            function triggerExplosion() {
                state.isExploded = true;
                timerElement.style.display = 'none';
                document.getElementById('instruction').style.display = 'none';
                
                // åˆå§‹åŒ–ç²’å­ (ä»å±å¹•ä¸­å¿ƒç‚¸å¼€)
                initExplosion(canvas.width / 2, canvas.height * 0.4);

                // æ˜¾ç¤ºç¥ç¦
                msgElement.style.opacity = 1;
                setTimeout(() => {
                    msgElement.style.opacity = 0;
                }, 4000);
            }

            // 6. æ¸²æŸ“å¾ªç¯
            function renderFrame(timestamp) {
                // å¹³æ»‘æ’å€¼åŠ¨ç”»
                const lerpSpeed = 0.1;
                state.currentAngle += (state.targetAngle - state.currentAngle) * lerpSpeed;
                state.currentScale += (state.targetScale - state.currentScale) * lerpSpeed;

                // å¾…æœºè‡ªåŠ¨å¾®åŠ¨ (å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹)
                let renderAngle = state.currentAngle;
                if (!state.handDetected && !state.isExploded) {
                    renderAngle += Math.sin(timestamp * 0.001) * 0.1;
                }

                // è°ƒç”¨é«˜çº§ç»˜åˆ¶å‡½æ•°
                drawGoldenTree(
                    ctx, 
                    canvas.width, 
                    canvas.height, 
                    timestamp, 
                    renderAngle, 
                    state.currentScale
                );

                requestAnimationFrame(renderFrame);
            }
            requestAnimationFrame(renderFrame);
        };
    </script>
</body>
</html>
