<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>Golden AR Tree Demo</title>
  <style>
    :root {
      --gold: #ffd700;
      --gold-soft: rgba(255, 215, 0, 0.6);
      --bg-dark: #02030a;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 20% 0%, #10152a 0, #02030a 55%, #000 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
      color: var(--gold);
    }

    .root {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* 中间画树的画布 */
    #treeCanvas {
      width: min(90vw, 480px);
      height: min(120vw, 640px);
    }

    /* 小窗口前置摄像头预览：右上角缩小 */
    .camera-preview {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 110px;
      height: 150px;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(255, 215, 0, 0.5);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
      background: #000;
      z-index: 10;
    }

    #cameraVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* 镜像自拍 */
    }

    /* 顶部倒计时 */
    .timer-badge {
      position: fixed;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      font-weight: 700;
      text-shadow: 0 0 10px #000;
    }

    /* 底部提示文案 */
    .hint-box {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255, 215, 0, 0.5);
      background: rgba(0, 0, 0, 0.7);
      font-size: 12px;
      text-align: center;
      line-height: 1.4;
      color: #ffe9a0;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
    }

    .hint-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--gold);
    }
  </style>
</head>
<body>
  <div class="root">
    <canvas id="treeCanvas"></canvas>
  </div>

  <!-- 小窗口摄像头 -->
  <div class="camera-preview">
    <video id="cameraVideo" autoplay playsinline muted></video>
  </div>

  <!-- 倒计时 -->
  <div id="timer" class="timer-badge">12s</div>

  <!-- 底部提示 -->
  <div class="hint-box">
    <div class="hint-title">✨ 金色圣诞树 Demo</div>
    <div>当前版：自动旋转预览<br />后续会接入「真正的手势识别」控制旋转与缩放</div>
  </div>

  <script>
    // ========= 1. 画布初始 =========
    const canvas = document.getElementById("treeCanvas");
    const ctx = canvas.getContext("2d");
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // ========= 2. 简单相机预览（右上角小窗） =========
    const videoEl = document.getElementById("cameraVideo");
    async function initCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false,
        });
        videoEl.srcObject = stream;
      } catch (e) {
        console.log("Camera error:", e);
      }
    }
    initCamera();

    // ========= 3. 画一棵「发光金色圣诞树」 =========
    function drawGoldenTree(t) {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      ctx.clearRect(0, 0, w, h);

      const cx = w / 2;
      const baseY = h * 0.8;
      const treeH = h * 0.7;
      const time = t * 0.001;

      // —— 夜空金雾背景 ——
      const bgGrad = ctx.createRadialGradient(
        cx,
        baseY - treeH * 0.35,
        treeH * 0.05,
        cx,
        baseY - treeH * 0.35,
        treeH * 1.0
      );
      bgGrad.addColorStop(0, "rgba(255, 215, 0, 0.18)");
      bgGrad.addColorStop(0.4, "rgba(255, 215, 0, 0.06)");
      bgGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, w, h);

      // —— 背景星点 ——
      ctx.save();
      for (let i = 0; i < 120; i++) {
        const ang = Math.random() * Math.PI * 2;
        const r = treeH * (0.15 + 0.55 * Math.random());
        const x = cx + Math.cos(ang) * r;
        const y = baseY - treeH * 0.4 + Math.sin(ang) * r * 0.6;
        const size = Math.random() * 1.4 + 0.3;
        const twinkle = 0.4 + 0.4 * Math.sin(time * 2 + i);
        ctx.fillStyle = `rgba(255, 240, 190, ${twinkle})`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      // —— 树身（多层发光云雾三角形） ——
      const layers = 7;
      for (let i = 0; i < layers; i++) {
        const p = i / (layers - 1); // 0~1
        const topY = baseY - treeH * (1 - p * 0.95);
        const bottomY = baseY - treeH * (1 - p - 0.12);
        const halfW = (1 - p * 0.9) * (w * 0.23);

        const sway = Math.sin(time * 1.4 + p * 4) * (4 * (1 - p));

        const grad = ctx.createLinearGradient(cx, topY, cx, bottomY);
        grad.addColorStop(0, "rgba(255, 255, 230, 0.95)");
        grad.addColorStop(0.35, "rgba(255, 235, 170, 0.98)");
        grad.addColorStop(0.8, "rgba(210, 150, 40, 0.95)");
        grad.addColorStop(1, "rgba(130, 80, 10, 0.9)");

        ctx.save();
        ctx.shadowColor = "rgba(255, 215, 0, 0.95)";
        ctx.shadowBlur = 24;

        ctx.beginPath();
        ctx.moveTo(cx + sway * 0.4, topY);
        ctx.quadraticCurveTo(
          cx - halfW * 0.3 + sway * 0.2,
          (topY + bottomY) / 2,
          cx - halfW + sway,
          bottomY
        );
        ctx.lineTo(cx + halfW + sway, bottomY);
        ctx.quadraticCurveTo(
          cx + halfW * 0.3 + sway * 0.2,
          (topY + bottomY) / 2,
          cx + sway * 0.4,
          topY
        );
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.restore();
      }

      // —— 金色丝带 ——
      ctx.save();
      ctx.lineWidth = 2.5;
      ctx.shadowColor = "rgba(255, 255, 200, 1)";
      ctx.shadowBlur = 16;
      const bandCount = 3;
      for (let i = 0; i < bandCount; i++) {
        const p = 0.32 + i * 0.16;
        const y = baseY - treeH * p;
        const bandW = w * (0.26 - i * 0.03);
        ctx.strokeStyle = "rgba(255, 245, 210, 0.95)";
        ctx.beginPath();
        ctx.moveTo(cx - bandW, y);
        ctx.quadraticCurveTo(
          cx + Math.sin(time * 1.3 + i) * 30,
          y + 8 * Math.sin(time * 2 + i),
          cx + bandW,
          y + 4
        );
        ctx.stroke();
      }
      ctx.restore();

      // —— 金币 / 元宝 / 宝石装饰 ——
      const ornaments = [
        { x: -0.18, y: 0.40, type: "coin" },
        { x: 0.20, y: 0.42, type: "gem" },
        { x: -0.24, y: 0.58, type: "ingot" },
        { x: 0.22, y: 0.63, type: "coin" },
        { x: -0.10, y: 0.70, type: "gem" },
        { x: 0.06, y: 0.33, type: "ingot" },
        { x: 0.0, y: 0.50, type: "coin" },
      ];

      ornaments.forEach((o, idx) => {
        const ox = cx + o.x * w * 0.5;
        const oy = baseY - treeH * o.y;
        const pulse = 1 + 0.15 * Math.sin(time * 3 + idx);
        ctx.save();
        ctx.translate(ox, oy);
        ctx.scale(pulse, pulse);
        ctx.shadowColor = "rgba(255, 215, 0, 1)";
        ctx.shadowBlur = 18;

        if (o.type === "coin") {
          const r = 7;
          const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
          grad.addColorStop(0, "#fffbe0");
          grad.addColorStop(0.4, "#ffe58a");
          grad.addColorStop(1, "#d89c1f");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.fill();
        } else if (o.type === "ingot") {
          ctx.fillStyle = "#ffd700";
          ctx.beginPath();
          ctx.moveTo(-10, 4);
          ctx.lineTo(0, -6);
          ctx.lineTo(10, 4);
          ctx.quadraticCurveTo(0, 10, -10, 4);
          ctx.closePath();
          ctx.fill();
        } else if (o.type === "gem") {
          ctx.fillStyle = "#fff3b0";
          ctx.beginPath();
          ctx.moveTo(0, -8);
          ctx.lineTo(7, 0);
          ctx.lineTo(0, 8);
          ctx.lineTo(-7, 0);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
      });

      // —— 顶部发光星星 ——
      const starY = baseY - treeH * 1.05;
      const starR = 14;
      ctx.save();
      ctx.translate(cx, starY);
      ctx.rotate(Math.sin(time * 1.5) * 0.15);
      ctx.shadowColor = "rgba(255, 255, 220, 1)";
      ctx.shadowBlur = 25;
      const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, starR * 1.4);
      grad.addColorStop(0, "#fffdf0");
      grad.addColorStop(0.4, "#ffe07a");
      grad.addColorStop(1, "rgba(255, 215, 0, 0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      for (let i = 0; i < 5; i++) {
        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
        const x1 = Math.cos(angle) * starR;
        const y1 = Math.sin(angle) * starR;
        const x2 = Math.cos(angle + Math.PI / 5) * (starR / 2.3);
        const y2 = Math.sin(angle + Math.PI / 5) * (starR / 2.3);
        if (i === 0) ctx.moveTo(x1, y1);
        else ctx.lineTo(x1, y1);
        ctx.lineTo(x2, y2);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // ========= 4. 动画 & 倒计时 =========
    let startTime = null;
    let remaining = 12;
    const timerEl = document.getElementById("timer");

    function loop(timestamp) {
      if (!startTime) startTime = timestamp;
      const elapsed = (timestamp - startTime) / 1000;
      const left = Math.max(0, 12 - elapsed);
      const intLeft = Math.ceil(left);
      if (intLeft !== remaining) {
        remaining = intLeft;
        timerEl.textContent = remaining + "s";
      }

      drawGoldenTree(timestamp);

      if (left > 0) {
        requestAnimationFrame(loop);
      } else {
        timerEl.textContent = "0s";
      }
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
