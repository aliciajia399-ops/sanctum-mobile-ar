<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Golden AR Christmas Tree</title>
    
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* è§†é¢‘èƒŒæ™¯å±‚ */
        #input-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ï¼Œæ›´ç¬¦åˆè‡ªæ‹ç›´è§‰ */
            z-index: 0;
        }

        /* Three.js æ¸²æŸ“å±‚ */
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* ä¹Ÿè¦é•œåƒç¿»è½¬ï¼Œä»¥ä¾¿å’Œè§†é¢‘å¯¹é½ */
            transform: scaleX(-1); 
        }

        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* è®©äº‹ä»¶ç©¿é€ */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* é¡¶éƒ¨å€’è®¡æ—¶ */
        #timer {
            margin-top: 20px;
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        /* æç¤ºæ–‡å­— */
        #instruction {
            margin-top: 10px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            text-align: center;
        }

        /* æœ€ç»ˆç¥ç¦æ–‡å­— */
        #final-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 165, 0, 1);
            opacity: 0;
            transition: opacity 1s ease-in;
            text-align: center;
            width: 80%;
        }

        /* åŠ è½½é®ç½© */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffd700;
            font-size: 20px;
            flex-direction: column;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>

    <canvas id="three-canvas"></canvas>

    <div id="ui-layer">
        <div id="timer">12</div>
        <div id="instruction">ğŸ– æŠŠæ‰‹æ”¾å…¥é•œå¤´ï¼šå·¦å³ç§»åŠ¨æ—‹è½¬ï¼Œè¿œè¿‘æ§åˆ¶å¤§å°</div>
        <div id="final-message">é—ºèœœä»Šå¹´åœ£è¯ä¸€èµ·æš´å¯Œï¼</div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div>å¯åŠ¨ AR å¼•æ“ä¸­...</div>
    </div>

    <script>
        // å…¨å±€çŠ¶æ€
        const state = {
            targetRotationY: 0,
            targetScale: 1,
            isExploded: false,
            timeLeft: 12,
            handDetected: false
        };

        // ==== BEGIN FIXED: Three.js golden Christmas tree model (DO NOT MODIFY) ====

        function initThreeScene(canvas) {
            const renderer = new THREE.WebGLRenderer({
                canvas,
                alpha: true,
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            renderer.setSize(window.innerWidth, window.innerHeight);

            const scene = new THREE.Scene();

            const camera = new THREE.PerspectiveCamera(
                30,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, 1.6, 8);

            const ambient = new THREE.AmbientLight(0xfff4ce, 0.6);
            scene.add(ambient);

            const keyLight = new THREE.DirectionalLight(0xffe08a, 1.2);
            keyLight.position.set(3, 6, 4);
            scene.add(keyLight);

            const rimLight = new THREE.PointLight(0xfff6b0, 1.0, 20);
            rimLight.position.set(-2, 4, -3);
            scene.add(rimLight);

            // é‡‘è‰²æè´¨
            const goldMat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.7,
                metalness: 0.95,
                roughness: 0.2
            });

            // åœ£è¯æ ‘ä¸»ä½“ï¼šå¤šä¸ªé”¥ä½“å åŠ 
            const treeGroup = new THREE.Group();

            const levels = 4;
            for (let i = 0; i < levels; i++) {
                const radius = 1.6 - i * 0.35;
                const height = 1.6 - i * 0.25;
                const geo = new THREE.ConeGeometry(radius, height, 64, 8);
                const mesh = new THREE.Mesh(geo, goldMat);
                mesh.position.y = i * 0.9;
                treeGroup.add(mesh);
            }

            // æ ‘å¹²
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 0.6, 24);
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                metalness: 0.3,
                roughness: 0.8
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = -0.7;
            treeGroup.add(trunk);

            // é¡¶éƒ¨æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(0.45, 1);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xfff6b0,
                emissive: 0xfff6b0,
                emissiveIntensity: 1.2,
                metalness: 0.9,
                roughness: 0.1
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = levels * 0.9;
            treeGroup.add(star);

            // é‡‘è‰²è£…é¥°çƒ
            const orbGeo = new THREE.SphereGeometry(0.18, 24, 16);
            const orbMat = new THREE.MeshStandardMaterial({
                color: 0xfff2c0,
                emissive: 0xfff2c0,
                emissiveIntensity: 0.9,
                metalness: 0.9,
                roughness: 0.3
            });

            const ringCount = 18;
            for (let i = 0; i < ringCount; i++) {
                const angle = (i / ringCount) * Math.PI * 2;
                const radius = 1.2 + (i % 3) * 0.1;
                const y = -0.1 + (i % 3) * 0.6;
                const orb = new THREE.Mesh(orbGeo, orbMat);
                orb.position.set(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
                treeGroup.add(orb);
            }

            // å¾®å°é‡‘è‰²ç²’å­ç¯ç»•
            const glowGeo = new THREE.SphereGeometry(0.06, 12, 12);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xfff6b0
            });
            const glowGroup = new THREE.Group();
            const glowCount = 80;
            for (let i = 0; i < glowCount; i++) {
                const g = new THREE.Mesh(glowGeo, glowMat);
                const r = 2.4 + Math.random() * 0.4;
                const ang = Math.random() * Math.PI * 2;
                const h = -0.5 + Math.random() * (levels * 0.9 + 1);
                g.position.set(
                    Math.cos(ang) * r,
                    h,
                    Math.sin(ang) * r
                );
                glowGroup.add(g);
            }
            treeGroup.add(glowGroup);

            treeGroup.position.set(0, 0.5, 0);
            scene.add(treeGroup);

            function onResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                renderer.setSize(w, h);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
            }
            window.addEventListener('resize', onResize);
            onResize();

            return { renderer, scene, camera, treeGroup, glowGroup };
        }

        // ==== END FIXED: Three.js golden Christmas tree model ====


        // ==========================================
        // ç²’å­çˆ†ç‚¸æ•ˆæœç³»ç»Ÿ
        // ==========================================
        class ExplosionSystem {
            constructor(scene, position) {
                this.scene = scene;
                this.particles = [];
                this.geometry = new THREE.BufferGeometry();
                this.active = false;
                
                // åˆ›å»ºé‡‘è‰²ç²’å­çº¹ç†
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16,16,0,16,16,16);
                grad.addColorStop(0, 'rgba(255, 230, 150, 1)');
                grad.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,32,32);
                const texture = new THREE.CanvasTexture(canvas);

                const material = new THREE.PointsMaterial({
                    color: 0xffd700,
                    size: 0.3,
                    map: texture,
                    transparent: true,
                    opacity: 1,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                // åˆå§‹åŒ–ç²’å­æ•°æ®
                const count = 1000;
                const positions = new Float32Array(count * 3);
                
                for(let i=0; i<count; i++) {
                    positions[i*3] = position.x;
                    positions[i*3+1] = position.y + 2; // ä»æ ‘ä¸­å¿ƒåä¸Šä¸€ç‚¹çˆ†å‘
                    positions[i*3+2] = position.z;
                    
                    this.particles.push({
                        vx: (Math.random() - 0.5) * 0.4,
                        vy: (Math.random() - 0.5) * 0.4,
                        vz: (Math.random() - 0.5) * 0.4,
                        life: 1.0 + Math.random() * 0.5
                    });
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.system = new THREE.Points(this.geometry, material);
                this.system.visible = false;
                scene.add(this.system);
            }

            trigger() {
                this.active = true;
                this.system.visible = true;
            }

            update() {
                if (!this.active) return;

                const positions = this.geometry.attributes.position.array;
                let aliveCount = 0;

                for(let i=0; i<this.particles.length; i++) {
                    const p = this.particles[i];
                    if (p.life > 0) {
                        p.life -= 0.01;
                        positions[i*3] += p.vx;
                        positions[i*3+1] += p.vy;
                        positions[i*3+2] += p.vz;
                        aliveCount++;
                    }
                }

                this.geometry.attributes.position.needsUpdate = true;
                
                // æ•´ä½“æ·¡å‡º
                if(this.system.material.opacity > 0) {
                    this.system.material.opacity -= 0.005;
                }

                if(this.system.material.opacity <= 0) {
                    this.active = false;
                    this.scene.remove(this.system);
                }
            }
        }


        window.onload = async function() {
            const videoElement = document.getElementById('input-video');
            const canvasElement = document.getElementById('three-canvas');
            const timerElement = document.getElementById('timer');
            const loadingElement = document.getElementById('loading');
            const msgElement = document.getElementById('final-message');

            // 1. åˆå§‹åŒ– Three.js åœºæ™¯
            const { renderer, scene, camera, treeGroup, glowGroup } = initThreeScene(canvasElement);
            const explosion = new ExplosionSystem(scene, treeGroup.position);

            // 2. åˆå§‹åŒ– MediaPipe Hands
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            // 3. å¯åŠ¨æ‘„åƒå¤´å¹¶ç»‘å®šåˆ° MediaPipe
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 1280,
                height: 720
            });
            
            try {
                await cameraUtils.start();
                loadingElement.style.display = 'none'; // æ‘„åƒå¤´å¯åŠ¨æˆåŠŸåéšè—loading
                startCountdown(); // å¼€å§‹å€’è®¡æ—¶
            } catch (err) {
                console.error(err);
                loadingElement.innerHTML = "<div>æ— æ³•å¼€å¯æ‘„åƒå¤´</div><div style='font-size:14px; margin-top:10px'>è¯·ç¡®ä¿ä½¿ç”¨HTTPSæˆ–æœ¬åœ°ç¯å¢ƒ</div>";
            }

            // 4. MediaPipe ç»“æœå¤„ç†é€»è¾‘
            function onResults(results) {
                if (state.isExploded) return; // çˆ†ç‚¸åä¸å†æ§åˆ¶

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    state.handDetected = true;
                    const landmarks = results.multiHandLandmarks[0];

                    // --- è®¡ç®—æ—‹è½¬ (Rotation) ---
                    // ä½¿ç”¨ä¸­æŒ‡æ ¹éƒ¨(9)ä½œä¸ºæ‰‹æŒä¸­å¿ƒç‚¹çš„å‚è€ƒ
                    // landmarks åæ ‡èŒƒå›´æ˜¯ [0, 1]ï¼Œ0åœ¨å·¦ï¼Œ1åœ¨å³
                    const palmX = landmarks[9].x; 
                    
                    // æ˜ å°„ logic: 
                    // ç”»é¢å·¦ä¾§ (x < 0.5) -> å‘å·¦è½¬ (-60åº¦)
                    // ç”»é¢å³ä¾§ (x > 0.5) -> å‘å³è½¬ (+60åº¦)
                    // è§’åº¦è½¬æ¢ä¸ºå¼§åº¦: 60åº¦ = PI/3
                    // æ³¨æ„ï¼šç”±äºCSS transform: scaleX(-1) é•œåƒäº†ç”»å¸ƒï¼Œè§†è§‰ä¸Šæ˜¯ç¬¦åˆç›´è§‰çš„
                    const maxRotation = Math.PI / 3; 
                    state.targetRotationY = (palmX - 0.5) * 2 * maxRotation;

                    // --- è®¡ç®—ç¼©æ”¾ (Scale) ---
                    // ä½¿ç”¨æ‰‹è…•(0)åˆ°ä¸­æŒ‡æ ¹éƒ¨(9)çš„è·ç¦»ä½œä¸ºæ‰‹æŒå¤§å°çš„å‚è€ƒ
                    const dx = landmarks[0].x - landmarks[9].x;
                    const dy = landmarks[0].y - landmarks[9].y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    // distance ä¸€èˆ¬åœ¨ 0.1 (è¿œ) åˆ° 0.4 (è¿‘) ä¹‹é—´
                    // æ˜ å°„åˆ° scale [0.7, 1.4]
                    // ç®€å•çº¿æ€§æ˜ å°„ï¼š scale = base + factor * distance
                    const scaleFactor = Math.min(Math.max(distance * 4, 0.7), 1.4);
                    state.targetScale = scaleFactor;

                } else {
                    state.handDetected = false;
                }
            }

            // 5. å€’è®¡æ—¶é€»è¾‘
            function startCountdown() {
                const timerId = setInterval(() => {
                    state.timeLeft--;
                    timerElement.innerText = state.timeLeft;

                    if (state.timeLeft <= 0) {
                        clearInterval(timerId);
                        triggerExplosion();
                    }
                }, 1000);
            }

            // 6. çˆ†ç‚¸é€»è¾‘
            function triggerExplosion() {
                state.isExploded = true;
                timerElement.style.display = 'none';
                document.getElementById('instruction').style.display = 'none';
                
                // éšè—æ ‘
                treeGroup.visible = false;
                
                // è§¦å‘ç²’å­
                explosion.trigger();

                // æ˜¾ç¤ºç¥ç¦è¯­
                msgElement.style.opacity = 1;
                setTimeout(() => {
                    msgElement.style.opacity = 0;
                }, 4000);
            }

            // 7. åŠ¨ç”»æ¸²æŸ“å¾ªç¯
            const clock = new THREE.Clock();
            
            function animate() {
                requestAnimationFrame(animate);

                const delta = clock.getDelta();

                if (!state.isExploded) {
                    // å¹³æ»‘æ’å€¼æ›´æ–°æ—‹è½¬ (Lerp)
                    treeGroup.rotation.y += (state.targetRotationY - treeGroup.rotation.y) * 5 * delta;
                    
                    // å¹³æ»‘æ’å€¼æ›´æ–°ç¼©æ”¾
                    const currentScale = treeGroup.scale.x;
                    const nextScale = currentScale + (state.targetScale - currentScale) * 5 * delta;
                    treeGroup.scale.set(nextScale, nextScale, nextScale);

                    // ç²’å­å…‰ç¯è‡ªè½¬ç‰¹æ•ˆ
                    glowGroup.rotation.y -= 0.5 * delta;
                    glowGroup.rotation.x = Math.sin(clock.getElapsedTime()) * 0.1;

                    // å¦‚æœæ²¡æ£€æµ‹åˆ°æ‰‹ï¼Œå¯ä»¥è®©æ ‘æœ‰ä¸€ä¸ªè½»å¾®çš„å‘¼å¸/æ‘†åŠ¨æ•ˆæœ
                    if (!state.handDetected) {
                        treeGroup.rotation.y = Math.sin(clock.getElapsedTime() * 0.5) * 0.2;
                    }
                } else {
                    // æ›´æ–°çˆ†ç‚¸ç²’å­
                    explosion.update();
                }

                renderer.render(scene, camera);
            }

            animate();
        };
    </script>
</body>
</html>
