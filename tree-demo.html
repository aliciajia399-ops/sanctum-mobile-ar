<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Luxury Golden AR Tree</title>
    
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        /* å¼ºåˆ¶é¡µé¢èƒŒæ™¯ä¸ºçº¯é»‘ï¼Œé˜²æ­¢ç™½è¾¹ */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000 !important; /* å¼ºåˆ¶é»‘è‰² */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        /* è§†é¢‘é¢„è§ˆå°çª—å£ (å³ä¸Šè§’) */
        #input-video {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 100px;
            height: auto;
            aspect-ratio: 3/4;
            object-fit: cover;
            border-radius: 12px;
            border: 2px solid rgba(255, 215, 0, 0.6);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            transform: scaleX(-1);
            z-index: 20;
            background: #222;
        }

        /* ä¸» Canvas */
        #three-canvas {
            display: block;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* å€’è®¡æ—¶ */
        #timer {
            margin-top: 40px;
            font-size: 60px;
            font-weight: 800;
            color: #FFD700;
            text-shadow: 0 0 30px rgba(255, 165, 0, 0.8);
            letter-spacing: 2px;
        }

        /* æç¤ºæ–‡å­— */
        #instruction {
            margin-top: 10px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(20, 20, 20, 0.8);
            padding: 10px 24px;
            border-radius: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            text-align: center;
            backdrop-filter: blur(5px);
        }

        /* æœ€ç»ˆç¥ç¦æ–‡å­— */
        #final-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 40px rgba(255, 140, 0, 1);
            opacity: 0;
            transition: opacity 1s ease-in;
            text-align: center;
            width: 90%;
            z-index: 30;
        }

        /* åŠ è½½é®ç½© */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffd700;
            font-size: 16px;
            flex-direction: column;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top: 3px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>
    <canvas id="three-canvas"></canvas>

    <div id="ui-layer">
        <div id="timer">12</div>
        <div id="instruction">
            ğŸ– ä¼¸æ‰‹å³å¯æ§åˆ¶<br>
            <span style="font-size:12px; opacity:0.7">å·¦å³ç§»åŠ¨æ—‹è½¬ Â· è¿œè¿‘æ§åˆ¶å¤§å°</span>
        </div>
        <div id="final-message">âœ¨ é—ºèœœä»Šå¹´åœ£è¯ä¸€èµ·æš´å¯Œï¼âœ¨</div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div>å¯åŠ¨å¥¢å AR å¼•æ“...</div>
    </div>

    <script>
        // === å…¨å±€çŠ¶æ€ ===
        const state = {
            targetRotationY: 0,
            currentRotationY: 0,
            targetScale: 1,
            currentScale: 1,
            isExploded: false,
            timeLeft: 12,
            handDetected: false,
            
            // åŠ¨ç”»é˜¶æ®µï¼š0=æ··æ²Œ, 1=èšåˆä¸­, 2=å®Œæˆ
            animPhase: 0, 
            startTime: Date.now()
        };

        const canvas = document.getElementById('three-canvas');
        const timerElement = document.getElementById('timer');
        const msgElement = document.getElementById('final-message');
        const instructionEl = document.getElementById('instruction');

        // Three.js å˜é‡
        let scene, camera, renderer;
        let treeContainer; 
        let particles, ornaments;
        let starMesh;
        let particleGeo, ornamentMesh;

        // ç”Ÿæˆå‘å…‰çº¹ç†
        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.3, 'rgba(255, 215, 0, 0.6)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        const sparkleTexture = createSparkleTexture();

        // === Three.js åˆå§‹åŒ– ===
        function initThree() {
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: false, // æ”¹ä¸º falseï¼Œè®© Three.js æ§åˆ¶èƒŒæ™¯è‰²
                antialias: true
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // æ ¸å¿ƒä¿®å¤ï¼šè®¾ç½®èƒŒæ™¯ä¸ºæå…¶æ·±çš„å¤œç©ºè“/é»‘ï¼Œè€Œä¸æ˜¯é€æ˜
            // è¿™æ ·åŠ æ³•æ··åˆ (AdditiveBlending) æ‰èƒ½åœ¨é»‘è‰²ä¸Šå‘å…‰
            scene = new THREE.Scene();
            scene.background = new THREE.Color('#050505'); 
            
            // åŠ ä¸Šä¸€ç‚¹é›¾æ°”ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
            scene.fog = new THREE.FogExp2(0x050505, 0.08);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1, 6); // è§†è§’å¾®å¾®æŠ¬é«˜

            treeContainer = new THREE.Group();
            scene.add(treeContainer);

            createLuxuryTree();

            // ç›‘å¬çª—å£
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // === æ„å»ºå¥¢ååœ£è¯æ ‘ ===
        function createLuxuryTree() {
            // 1. é‡‘è‰²ç²’å­ (é’ˆå¶)
            const particleCount = 3500;
            particleGeo = new THREE.BufferGeometry();
            const pPos = [], pTarget = [], pChaos = [], pSizes = [], pColors = [];
            const colorPalette = [
                new THREE.Color('#FFD700'), // é‡‘
                new THREE.Color('#FFA500'), // æ©™é‡‘
                new THREE.Color('#FFFFE0'), // äº®ç™½
            ];

            // åˆ†å±‚é€»è¾‘
            const layers = 6;
            const treeHeight = 3.5;
            
            for(let i=0; i<particleCount; i++) {
                // éšæœºåˆ†é…åˆ°æŸä¸€å±‚
                const layerIdx = Math.floor(Math.random() * layers);
                // å±‚è¿›åº¦ 0(é¡¶) -> 1(åº•)
                const layerProgress = layerIdx / (layers - 1); 
                
                // åœ†é”¥ä½“å‚æ•°
                const layerYBase = 1.5 - (layerIdx * 0.6); // å±‚é«˜ä½ç½®
                const layerRadius = 0.2 + (layerIdx * 0.5); // å±‚åŠå¾„

                // åœ¨åœ†é”¥è¡¨é¢/å†…éƒ¨ç”Ÿæˆç‚¹
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * layerRadius;
                // è®©ç²’å­ç¨å¾®æœ‰ç‚¹åšåº¦ï¼Œä¸ä»…æ˜¯è¡¨é¢
                const yOffset = (Math.random() - 0.5) * 0.5; 
                
                const tx = Math.cos(angle) * r;
                const ty = layerYBase + yOffset;
                const tz = Math.sin(angle) * r;

                pTarget.push(tx, ty, tz);

                // æ··æ²Œåˆå§‹ä½ç½® (å±å¹•å¤–ä¹±é£)
                const cx = (Math.random() - 0.5) * 20;
                const cy = (Math.random() - 0.5) * 20;
                const cz = (Math.random() - 0.5) * 10;
                pChaos.push(cx, cy, cz);
                pPos.push(cx, cy, cz); // åˆå§‹=æ··æ²Œ

                pSizes.push(Math.random() * 0.15 + 0.05);
                const col = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                pColors.push(col.r, col.g, col.b);
            }

            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            particleGeo.setAttribute('target', new THREE.Float32BufferAttribute(pTarget, 3));
            particleGeo.setAttribute('chaos', new THREE.Float32BufferAttribute(pChaos, 3));
            particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(pColors, 3));
            particleGeo.setAttribute('size', new THREE.Float32BufferAttribute(pSizes, 1));

            const pMat = new THREE.PointsMaterial({
                map: sparkleTexture,
                size: 0.1,
                vertexColors: true,
                blending: THREE.AdditiveBlending, // å…³é”®ï¼šå‘å…‰å åŠ 
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(particleGeo, pMat);
            treeContainer.add(particles);

            // 2. å®ä½“è£…é¥°çƒ (InstancedMesh) - è®©æ ‘çœ‹èµ·æ¥æœ‰å®ä½“æ„Ÿ
            const orbGeo = new THREE.SphereGeometry(0.1, 16, 16);
            const orbMat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xaa6600,
                emissiveIntensity: 0.2
            });
            
            const orbCount = 80;
            ornaments = new THREE.InstancedMesh(orbGeo, orbMat, orbCount);
            
            const dummy = new THREE.Object3D();
            const orbTargets = []; // å­˜å‚¨çƒçš„ç›®æ ‡ä½ç½®

            for(let i=0; i<orbCount; i++) {
                // éšæœºæŒ‚åœ¨æ ‘çš„è¾¹ç¼˜
                const layerIdx = Math.floor(Math.random() * layers);
                const layerYBase = 1.5 - (layerIdx * 0.6);
                const layerRadius = 0.2 + (layerIdx * 0.5);

                const angle = Math.random() * Math.PI * 2;
                // æŒ‚åœ¨æ¯ä¸€å±‚çš„å¤–ç¼˜
                const r = layerRadius * (0.8 + Math.random()*0.3);
                
                const tx = Math.cos(angle) * r;
                const ty = layerYBase + (Math.random()-0.5)*0.4;
                const tz = Math.sin(angle) * r;

                // åˆå§‹ä½ç½®è®¾åœ¨å¾ˆè¿œ
                dummy.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*20, -5);
                dummy.scale.setScalar(0); // åˆå§‹ä¸å¯è§
                dummy.updateMatrix();
                ornaments.setMatrixAt(i, dummy.matrix);

                // è®°å½•ç›®æ ‡ä½ç½®å’Œæœ€ç»ˆå¤§å°
                orbTargets.push({
                    x: tx, y: ty, z: tz,
                    scale: 0.8 + Math.random() * 0.6 // å¤§å°ä¸ä¸€
                });
            }
            ornaments.instanceMatrix.needsUpdate = true;
            ornaments.userData = { targets: orbTargets }; // å­˜èµ·æ¥ç»™åŠ¨ç”»ç”¨
            treeContainer.add(ornaments);

            // 3. é¡¶éƒ¨å¤§æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(0.25, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // ç®€å•çš„å‘å…‰ç™½èŠ¯
            starMesh = new THREE.Mesh(starGeo, starMat);
            starMesh.position.set(0, 2.0, 0);
            
            // æ˜Ÿæ˜Ÿçš„å…‰æ™•
            const starGlowMat = new THREE.SpriteMaterial({ 
                map: sparkleTexture, 
                color: 0xffd700, 
                blending: THREE.AdditiveBlending 
            });
            const starGlow = new THREE.Sprite(starGlowMat);
            starGlow.scale.set(1.5, 1.5, 1.5);
            starMesh.add(starGlow);
            
            starMesh.scale.setScalar(0); // åˆå§‹éšè—
            treeContainer.add(starMesh);

            // 4. ç¯å…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambient);
            
            const dirLight = new THREE.DirectionalLight(0xffd700, 2);
            dirLight.position.set(2, 5, 5);
            scene.add(dirLight);

            const pointLight = new THREE.PointLight(0xffaa00, 2, 10);
            pointLight.position.set(0, 1, 2);
            scene.add(pointLight);
        }

        // === åŠ¨ç”»å¾ªç¯ ===
        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const elapsed = (now - state.startTime) / 1000;

            if (!state.isExploded) {
                // é˜¶æ®µ1: èšåˆ (0s - 3s)
                if (elapsed < 3.5) {
                    state.animPhase = 1;
                    const progress = Math.min(elapsed / 3, 1);
                    // easeOutQuart
                    const t = 1 - Math.pow(1 - progress, 4);

                    // ç²’å­èšåˆ
                    updateParticlesLerp(t);
                    // è£…é¥°çƒèšåˆ
                    updateOrnamentsLerp(t);
                    // æ˜Ÿæ˜Ÿå‡ºç°
                    const starS = Math.max(0, (progress - 0.7) * 3.3); // å»¶è¿Ÿä¸€ç‚¹å‡ºç°
                    starMesh.scale.setScalar(starS);
                    
                    instructionEl.innerHTML = `âœ¨ æ­£åœ¨å‡èšé‡‘è‰²èƒ½é‡... ${(progress*100).toFixed(0)}%`;
                } 
                // é˜¶æ®µ2: äº’åŠ¨ (3s+)
                else {
                    if (state.animPhase === 1) {
                        state.animPhase = 2;
                        instructionEl.innerHTML = `ğŸ‘‹ å·¦å³ç§»åŠ¨æ—‹è½¬ Â· è¿œè¿‘æ§åˆ¶å¤§å°`;
                    }
                    
                    // æ‰‹åŠ¿æ§åˆ¶æ’å€¼
                    state.currentRotationY += (state.targetRotationY - state.currentRotationY) * 0.1;
                    state.currentScale += (state.targetScale - state.currentScale) * 0.1;

                    // æŒç»­è‡ªè½¬ + æ‰‹åŠ¿
                    treeContainer.rotation.y = state.currentRotationY + elapsed * 0.2;
                    // å‘¼å¸æ•ˆæœ + æ‰‹åŠ¿
                    const breath = 1 + Math.sin(elapsed * 1.5) * 0.03;
                    const finalScale = state.currentScale * breath;
                    treeContainer.scale.set(finalScale, finalScale, finalScale);

                    // æ˜Ÿæ˜Ÿè‡ªè½¬
                    starMesh.rotation.y -= 0.02;
                }
            } else {
                // çˆ†ç‚¸é€»è¾‘
                updateExplosion();
            }

            renderer.render(scene, camera);
        }

        // ç²’å­æ’å€¼
        function updateParticlesLerp(t) {
            const pos = particleGeo.attributes.position.array;
            const target = particleGeo.attributes.target.array;
            const chaos = particleGeo.attributes.chaos.array;

            for(let i=0; i<pos.length; i++) {
                pos[i] = chaos[i] + (target[i] - chaos[i]) * t;
            }
            particleGeo.attributes.position.needsUpdate = true;
        }

        // è£…é¥°çƒæ’å€¼
        const dummy = new THREE.Object3D();
        function updateOrnamentsLerp(t) {
            const targets = ornaments.userData.targets;
            for(let i=0; i<targets.length; i++) {
                const tg = targets[i];
                // ä»è¿œå¤„(æ¨¡æ‹Ÿ chaos)é£åˆ°ä½
                const startX = tg.x * 5; 
                const startY = tg.y + 5;
                const startZ = tg.z * 5;

                dummy.position.set(
                    startX + (tg.x - startX) * t,
                    startY + (tg.y - startY) * t,
                    startZ + (tg.z - startZ) * t
                );
                dummy.scale.setScalar(tg.scale * t); // æ…¢æ…¢å˜å¤§
                dummy.updateMatrix();
                ornaments.setMatrixAt(i, dummy.matrix);
            }
            ornaments.instanceMatrix.needsUpdate = true;
        }

        // çˆ†ç‚¸åŠ¨ç”»
        function explodeTree() {
            state.isExploded = true;
            timerElement.style.display = 'none';
            instructionEl.style.display = 'none';
            msgElement.style.opacity = 1;
            
            // å‡†å¤‡çˆ†ç‚¸é€Ÿåº¦å‘é‡
            const count = particleGeo.attributes.position.count;
            const vels = [];
            for(let i=0; i<count; i++) {
                vels.push(
                    (Math.random()-0.5)*0.5, 
                    (Math.random()-0.5)*0.5, 
                    (Math.random()-0.5)*0.5
                );
            }
            particleGeo.userData.velocities = vels;
            
            // éšè—å®ä½“çƒå’Œæ˜Ÿæ˜Ÿ
            ornaments.visible = false;
            starMesh.visible = false;

            setTimeout(() => { msgElement.style.opacity = 0; }, 4000);
        }

        function updateExplosion() {
            const pos = particleGeo.attributes.position.array;
            const vels = particleGeo.userData.velocities;
            if(!vels) return;

            for(let i=0; i<pos.length/3; i++) {
                pos[i*3] += vels[i*3];
                pos[i*3+1] += vels[i*3+1];
                pos[i*3+2] += vels[i*3+2];
                // é‡åŠ›
                vels[i*3+1] -= 0.005; 
            }
            particleGeo.attributes.position.needsUpdate = true;
            
            // ç²’å­æè´¨æ…¢æ…¢æ¶ˆå¤±
            if (particles.material.opacity > 0) {
                particles.material.opacity -= 0.01;
            }
        }


        // === å¯åŠ¨é€»è¾‘ ===
        window.onload = async function() {
            initThree();
            animate();

            const videoElement = document.getElementById('input-video');
            const loadingElement = document.getElementById('loading');
            const timerElement = document.getElementById('timer');

            // MediaPipe Hands
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            
            hands.onResults(results => {
                if (state.animPhase < 2) return; 

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    state.handDetected = true;
                    const landmarks = results.multiHandLandmarks[0];
                    const palmX = landmarks[9].x; 
                    state.targetRotationY = (palmX - 0.5) * 3; // æ—‹è½¬

                    const dx = landmarks[0].x - landmarks[9].x;
                    const dy = landmarks[0].y - landmarks[9].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    state.targetScale = Math.min(Math.max(dist * 4, 0.7), 1.6); // ç¼©æ”¾
                } else {
                    state.handDetected = false;
                    state.targetRotationY = 0;
                    state.targetScale = 1;
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            
            try {
                await cameraUtils.start();
                loadingElement.style.display = 'none'; 
                
                // å¼€å§‹å€’è®¡æ—¶
                const timerId = setInterval(() => {
                    if (state.timeLeft > 0) {
                        state.timeLeft--;
                        timerElement.innerText = state.timeLeft;
                    } else {
                        clearInterval(timerId);
                        explodeTree();
                    }
                }, 1000);

            } catch (err) {
                console.error(err);
                loadingElement.innerHTML = "<div>æ‘„åƒå¤´æ— æ³•å¯åŠ¨</div><div style='font-size:12px;opacity:0.7'>è¯·ç¡®ä¿ä½¿ç”¨HTTPS</div>";
            }
        };
    </script>
</body>
</html>
