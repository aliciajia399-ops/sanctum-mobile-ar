<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR æ‹›è´¢çŒ« - 2025 æš´å¯Œç‰ˆ</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: "Microsoft YaHei", sans-serif; }
        
        /* å³ä¸Šè§’æ‘„åƒå¤´é¢„è§ˆ */
        #input-video {
            position: fixed; top: 16px; right: 16px; width: 100px; height: auto;
            border-radius: 10px; border: 2px solid rgba(255, 215, 0, 0.5);
            transform: scaleX(-1); z-index: 20; background: #222; opacity: 0.8;
        }

        #three-canvas { display: block; width: 100%; height: 100%; z-index: 10; }

        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 15; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
        }

        /* çŠ¶æ€æç¤ºèƒ¶å›Š */
        #status-pill {
            margin-top: 40px; padding: 8px 20px; border-radius: 30px;
            background: rgba(20, 20, 20, 0.8); border: 1px solid rgba(255, 215, 0, 0.4);
            color: #FFD700; font-weight: bold; font-size: 14px;
            display: flex; gap: 10px; align-items: center;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
        }

        /* èƒ½é‡æ¡ */
        #charge-bar-container {
            margin-top: 10px; width: 150px; height: 6px;
            background: rgba(255,255,255,0.2); border-radius: 3px; overflow: hidden;
            opacity: 0; transition: opacity 0.3s;
        }
        #charge-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #ff8800, #ffd700); transition: width 0.1s linear; }

        /* æ“ä½œæŒ‡å— */
        #guide-panel {
            position: absolute; bottom: 40px; display: flex; gap: 20px;
            background: rgba(0,0,0,0.7); padding: 12px 24px; border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .guide-item { text-align: center; color: rgba(255,255,255,0.8); font-size: 12px; }
        .guide-icon { font-size: 24px; display: block; margin-bottom: 4px; }

        /* åŠ è½½é¡µ */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            color: #ffd700; flex-direction: column; gap: 15px; text-align: center; padding: 20px;
        }
        #error-log { color: #ff4444; font-size: 12px; margin-top: 10px; max-width: 80%; word-break: break-all; opacity: 0.8; }
        
        .spinner {
            width: 40px; height: 40px; border: 3px solid #333; border-top: 3px solid #ffd700;
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline></video>
    <canvas id="three-canvas"></canvas>

    <div id="ui-layer">
        <div id="status-pill">
            <span id="gesture-icon">âœ‹</span>
            <span id="gesture-text">å¯»æ‰¾æ‰‹åŠ¿ä¸­...</span>
        </div>
        <div id="charge-bar-container"><div id="charge-bar"></div></div>
        
        <div id="guide-panel">
            <div class="guide-item"><span class="guide-icon">âœŠ</span>æŠ“å–æ‹‰è¿‘</div>
            <div class="guide-item"><span class="guide-icon">ğŸ–</span>å¼ å¼€æ¨è¿œ</div>
            <div class="guide-item"><span class="guide-icon">âœŒï¸</span>è“„åŠ›å˜èº«</div>
        </div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text" style="margin-top:15px">æ­£åœ¨å¬å”¤æ‹›è´¢çŒ«...</div>
        <div id="error-log"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';

        // === æ ¸å¿ƒé…ç½® (å·²æ›´æ–°æ–‡ä»¶å) ===
        const CONFIG = {
            modelUrl: './cutecat01.glb', // ä½ çš„æ–°æ–‡ä»¶å
            wishText: "Fortune 2025",
            particleCount: 4500,
            modelScale: 3.5,       // æ¨¡å‹å¤§å°
            modelYOffset: -1.5,    // æ¨¡å‹å‚ç›´ä½ç½®
            
            // æ‰‹åŠ¿é˜ˆå€¼ (é˜²è¯¯è§¦ä¼˜åŒ–)
            spreadRatio: 1.5,      // å¼ å¼€æ‰‹æŒ‡åˆ¤å®šé˜ˆå€¼
            shakeThreshold: 3.5,   // éœ‡åŠ¨åˆ¤å®šé˜ˆå€¼
        };

        const state = {
            targetRotationY: 0, targetScale: 1,
            currentRotationY: 0, currentScale: 1,
            isExploded: false, victoryCharge: 0,
            handDetected: false,
            modelLoaded: false,
            // åŠ¨ä½œæ£€æµ‹è¾…åŠ©
            lastHandTime: 0,
            lastHandCenter: {x:0, y:0},
            currentGesture: 'NONE'
        };

        let scene, camera, renderer, clock;
        let mainGroup, particles, particleGeo, particleMat;

        // === 1. åˆå§‹åŒ– Three.js ===
        function initThree() {
            const canvas = document.getElementById('three-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, alpha: false, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            scene = new THREE.Scene();
            scene.background = new THREE.Color('#050505');
            scene.fog = new THREE.FogExp2(0x050505, 0.05);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1, 8);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // ç¯å…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffd700, 1.5);
            dirLight.position.set(2, 5, 5);
            scene.add(dirLight);

            loadModel();
            
            clock = new THREE.Clock();
            animate();
        }

        // === 2. åŠ è½½æ¨¡å‹ & ç²’å­åŒ– ===
        function loadModel() {
            const loader = new GLTFLoader();
            const loadingText = document.getElementById('loading-text');
            const errorLog = document.getElementById('error-log');

            console.log("åŠ è½½æ¨¡å‹:", CONFIG.modelUrl);

            loader.load(
                CONFIG.modelUrl, 
                (gltf) => {
                    console.log("æ¨¡å‹åŠ è½½æˆåŠŸ");
                    const model = gltf.scene;
                    
                    model.scale.setScalar(CONFIG.modelScale);
                    model.position.y = CONFIG.modelYOffset;
                    model.updateMatrixWorld(true);

                    let combinedPos = [], combinedTarget = [], combinedCol = [], combinedSize = [];
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            const data = sampleParticlesFromMesh(child, CONFIG.particleCount);
                            combinedPos.push(...data.positions);
                            combinedTarget.push(...data.targetPositions);
                            combinedCol.push(...data.colors);
                            combinedSize.push(...data.sizes);
                        }
                    });

                    if (combinedPos.length === 0) throw new Error("æ¨¡å‹ä¸­æ²¡æœ‰ç½‘æ ¼æ•°æ®");

                    createParticleSystem(combinedPos, combinedTarget, combinedCol, combinedSize);
                    
                    document.getElementById('loading').style.display = 'none';
                    state.modelLoaded = true;
                }, 
                (xhr) => {
                    const p = (xhr.loaded / xhr.total * 100).toFixed(0);
                    if (isFinite(p)) loadingText.innerText = `åŠ è½½ä¸­... ${p}%`;
                },
                (error) => {
                    console.error(error);
                    errorLog.innerText = `åŠ è½½å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}\nå¯åŠ¨å¤‡ç”¨æ–¹æ¡ˆ...`;
                    setTimeout(() => {
                        createFallbackCube();
                        document.getElementById('loading').style.display = 'none';
                        state.modelLoaded = true;
                    }, 2000);
                }
            );
        }

        // === 3. é‡‡æ ·ç®—æ³• ===
        function sampleParticlesFromMesh(mesh, count) {
            const samplerGeometry = mesh.geometry.toNonIndexed();
            const posAttr = samplerGeometry.getAttribute('position');
            const positions = [], targetPositions = [], colors = [], sizes = [];
            const totalTris = posAttr.count / 3;
            
            for (let i = 0; i < count; i++) {
                const triIdx = Math.floor(Math.random() * totalTris);
                const i3 = triIdx * 3;

                const a = new THREE.Vector3(posAttr.getX(i3), posAttr.getY(i3), posAttr.getZ(i3));
                const b = new THREE.Vector3(posAttr.getX(i3+1), posAttr.getY(i3+1), posAttr.getZ(i3+1));
                const c = new THREE.Vector3(posAttr.getX(i3+2), posAttr.getY(i3+2), posAttr.getZ(i3+2));

                let r1 = Math.random(), r2 = Math.random();
                if (r1 + r2 > 1) { r1 = 1 - r1; r2 = 1 - r2; }
                const p = new THREE.Vector3().addScaledVector(a, r1).addScaledVector(b, r2).addScaledVector(c, 1 - r1 - r2);
                p.applyMatrix4(mesh.matrixWorld);

                targetPositions.push(p.x, p.y, p.z);
                positions.push((Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*15);

                // æ‹›è´¢çŒ«é…è‰²ï¼šçº¢/é‡‘/ç™½
                const rand = Math.random();
                if (rand > 0.8) { colors.push(1.0, 0.2, 0.2); sizes.push(0.09); } // çº¢
                else if (rand > 0.5) { colors.push(1.0, 0.84, 0.0); sizes.push(0.07); } // é‡‘
                else { colors.push(1.0, 1.0, 0.9); sizes.push(0.05); } // ç™½
            }
            return { positions, targetPositions, colors, sizes };
        }

        // === 4. ç²’å­ç³»ç»Ÿæ„å»º ===
        function createParticleSystem(pos, target, col, size) {
            particleGeo = new THREE.BufferGeometry();
            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            particleGeo.setAttribute('target', new THREE.Float32BufferAttribute(target, 3));
            particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
            particleGeo.setAttribute('size', new THREE.Float32BufferAttribute(size, 1));

            // æ–‡å­—ç›®æ ‡
            const textTargets = createTextTargets(CONFIG.wishText);
            const textAttr = [];
            for(let i=0; i<pos.length/3; i++) {
                const t = textTargets[i % textTargets.length];
                textAttr.push(t.x, t.y, t.z);
            }
            particleGeo.setAttribute('textTarget', new THREE.Float32BufferAttribute(textAttr, 3));

            const tex = createGlowTexture();
            particleMat = new THREE.PointsMaterial({
                map: tex, size: 0.1, vertexColors: true,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9
            });

            particles = new THREE.Points(particleGeo, particleMat);
            mainGroup.add(particles);
        }

        function createFallbackCube() {
            const count = 3000;
            const pos = [], target = [], col = [], size = [];
            for(let i=0; i<count; i++) {
                pos.push((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
                target.push((Math.random()-0.5)*3, (Math.random()-0.5)*3, (Math.random()-0.5)*3);
                col.push(1, 0.8, 0); size.push(0.06);
            }
            createParticleSystem(pos, target, col, size);
        }

        // === 5. è¾…åŠ©çº¹ç† ===
        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.4,'rgba(255,255,255,0.2)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        function createTextTargets(text) {
            const c = document.createElement('canvas'); const ctx = c.getContext('2d');
            c.width = 1024; c.height = 256;
            ctx.font = `bold 100px Arial`; ctx.fillStyle = 'white';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, c.width/2, c.height/2);
            const data = ctx.getImageData(0,0,c.width,c.height).data;
            const targets = [];
            for(let y=0; y<c.height; y+=6) {
                for(let x=0; x<c.width; x+=6) {
                    if(data[(y*c.width+x)*4 + 3] > 128) {
                        targets.push({ x: (x-c.width/2)*0.015, y: -(y-c.height/2)*0.015 + 0.5, z: 0 });
                    }
                }
            }
            return targets;
        }

        // === 6. åŠ¨ç”»å¾ªç¯ ===
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (!state.modelLoaded) return;

            if (!state.isExploded) {
                // å¹³æ»‘æ’å€¼ (Lerp)
                state.currentRotationY += (state.targetRotationY - state.currentRotationY) * 0.1;
                state.currentScale += (state.targetScale - state.currentScale) * 0.08;

                mainGroup.rotation.y = state.currentRotationY + time * 0.1;
                mainGroup.scale.setScalar(state.currentScale);

                // ç²’å­èšåˆ
                const pos = particleGeo.attributes.position.array;
                const target = particleGeo.attributes.target.array;
                for(let i=0; i<pos.length; i++) pos[i] += (target[i] - pos[i]) * 0.08;
                particleGeo.attributes.position.needsUpdate = true;

                // è“„åŠ›æ¡åŠ¨ç”»
                handleCharge();
            } else {
                // æ–‡å­—é‡ç»„
                const pos = particleGeo.attributes.position.array;
                const textT = particleGeo.attributes.textTarget.array;
                for(let i=0; i<pos.length; i+=3) {
                    pos[i] += (textT[i] - pos[i]) * 0.05 + (Math.random()-0.5)*0.005;
                    pos[i+1] += (textT[i+1] - pos[i+1]) * 0.05 + (Math.random()-0.5)*0.005;
                    pos[i+2] += (textT[i+2] - pos[i+2]) * 0.05;
                }
                particleGeo.attributes.position.needsUpdate = true;
                mainGroup.rotation.y = Math.sin(time*0.5)*0.1;
            }
            renderer.render(scene, camera);
        }

        function handleCharge() {
            const bar = document.getElementById('charge-bar');
            const container = document.getElementById('charge-bar-container');
            const status = document.getElementById('gesture-text');

            if (state.currentGesture === 'VICTORY') {
                state.victoryCharge += 1.0; // å‡æ…¢å……èƒ½é€Ÿåº¦
                container.style.opacity = 1;
                
                // éœ‡åŠ¨ç‰¹æ•ˆ
                mainGroup.position.x = (Math.random()-0.5) * 0.05;
                mainGroup.position.y = (Math.random()-0.5) * 0.05;
                
                if (state.victoryCharge >= 100) {
                    state.isExploded = true;
                    document.getElementById('ui-layer').style.display = 'none';
                    // ç‚¸å¼€ä¸€ä¸‹
                    const pos = particleGeo.attributes.position.array;
                    for(let i=0; i<pos.length; i++) pos[i] += (Math.random()-0.5) * 5;
                }
            } else {
                state.victoryCharge = Math.max(0, state.victoryCharge - 2.5); // å¿«é€Ÿè¡°å‡
                if(state.victoryCharge <= 0) container.style.opacity = 0;
                mainGroup.position.set(0,0,0);
            }
            bar.style.width = state.victoryCharge + "%";
        }

        // === 7. æ‰‹åŠ¿è¯†åˆ« (é˜²è¯¯è§¦ç‰ˆ) ===
        function detectGesture(lm) {
            // è®¡ç®—åŸºå‡†ï¼šæ‰‹æŒå¤§å°
            const palmSize = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);

            // è¾…åŠ©ï¼šåˆ¤æ–­æ‰‹æŒ‡ä¼¸ç›´
            const isExtended = (tip, pip) => {
                const dist = Math.hypot(lm[tip].x - lm[0].x, lm[tip].y - lm[0].y);
                // é˜ˆå€¼ï¼šæŒ‡å°–è·ç¦»å¿…é¡» > æ‰‹æŒå¤§å° * 1.5 (é¿å…æ¡æ‹³æ—¶è¯¯åˆ¤)
                return dist > palmSize * CONFIG.spreadRatio;
            };

            const indexOpen = isExtended(8, 5);
            const middleOpen = isExtended(12, 9);
            const ringOpen = isExtended(16, 13);
            const pinkyOpen = isExtended(20, 17);
            const thumbOpen = Math.hypot(lm[4].x - lm[17].x, lm[4].y - lm[17].y) > palmSize * 1.2;

            const openCount = [thumbOpen, indexOpen, middleOpen, ringOpen, pinkyOpen].filter(Boolean).length;

            // çŠ¶æ€æœº
            if (openCount <= 1) return 'FIST'; // æ¡æ‹³
            if (openCount >= 4) return 'OPEN'; // å¼ å¼€
            // å‰ªåˆ€æ‰‹ï¼šé£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œæ— åæŒ‡å°æŒ‡å¼¯æ›²
            if (indexOpen && middleOpen && !ringOpen && !pinkyOpen) return 'VICTORY';
            
            return 'NEUTRAL';
        }

        window.onload = function() {
            const video = document.getElementById('input-video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6});
            
            hands.onResults(results => {
                if (results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    state.handDetected = true;
                    state.currentGesture = detectGesture(lm);
                    
                    // UIåé¦ˆ
                    const icon = document.getElementById('gesture-icon');
                    const text = document.getElementById('gesture-text');
                    
                    // é€»è¾‘æ˜ å°„
                    if (state.currentGesture === 'FIST') {
                        state.targetScale = 1.5; // æ‹‰è¿‘
                        icon.innerText = "âœŠ"; text.innerText = "æŠ“å–æ‹‰è¿‘";
                    } else if (state.currentGesture === 'OPEN') {
                        state.targetScale = 0.8; // æ¨è¿œ
                        icon.innerText = "ğŸ–"; text.innerText = "å¼ å¼€æ¨è¿œ";
                    } else if (state.currentGesture === 'VICTORY') {
                        icon.innerText = "âœŒï¸"; text.innerText = "è“„åŠ›å˜èº«...";
                    } else {
                        state.targetScale = 1.0;
                        icon.innerText = "âœ‹"; text.innerText = "æ§åˆ¶ä¸­";
                    }

                    // æ—‹è½¬ (å§‹ç»ˆç”Ÿæ•ˆ)
                    const palmX = lm[9].x; 
                    state.targetRotationY = (palmX - 0.5) * 3;

                } else {
                    state.handDetected = false;
                    state.targetRotationY = 0;
                    state.targetScale = 1;
                    document.getElementById('gesture-icon').innerText = "ğŸ‘€";
                    document.getElementById('gesture-text').innerText = "å¯»æ‰¾æ‰‹åŠ¿...";
                }
            });

            const camera = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            camera.start();
            initThree();
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
