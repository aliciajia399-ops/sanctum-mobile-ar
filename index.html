<!DOCTYPE html>
<html lang="en">
<head>
    <title>Christmas AR Demo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        /* A simple overlay instruction */
        #overlay {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            z-index: 1;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

    <div id="overlay">Find a floor area and Tap to place the Tree</div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
        import { ARButton } from 'https://unpkg.com/three@0.128.0/examples/jsm/webxr/ARButton.js';

        let container;
        let camera, scene, renderer;
        let controller;
        
        let reticle; // The visual marker for where to place the object
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        let treeGroup; // Will hold our Christmas Tree
        let particles; // Snow system
        let ornaments = []; // Array to store lights for blinking animation

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            // 1. Setup Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // 2. Setup Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            // 3. Setup Renderer (Alpha true is required for AR camera feed)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true; // Enable WebXR
            container.appendChild(renderer.domElement);

            // 4. Add AR Button to DOM
            // 'requiredFeatures': ['hit-test'] asks the browser for plane detection capabilities
            document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

            // 5. Build the Reticle (The circle that shows where you are aiming)
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // Green ring
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // 6. Build the Christmas Tree (Hidden initially)
            createChristmasTree();
            treeGroup.visible = false; 
            scene.add(treeGroup);

            // 7. Interaction (Tap to Place)
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            window.addEventListener('resize', onWindowResize);
        }

        // --- Procedural Tree Generation ---
        function createChristmasTree() {
            treeGroup = new THREE.Group();

            // Materials
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x0f5f0f, roughness: 0.8 });
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
            const starMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd000, emissiveIntensity: 0.5 });

            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5);
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 0.25;
            treeGroup.add(trunk);

            // Leaves (3 Cones stacked)
            const levels = [
                { r: 0.6, h: 0.8, y: 0.6 },
                { r: 0.45, h: 0.7, y: 1.1 },
                { r: 0.3, h: 0.6, y: 1.5 }
            ];

            levels.forEach(level => {
                const coneGeo = new THREE.ConeGeometry(level.r, level.h, 32);
                const cone = new THREE.Mesh(coneGeo, leafMat);
                cone.position.y = level.y;
                treeGroup.add(cone);
                
                // Add Ornaments per level
                addOrnaments(level.y, level.r, level.h);
            });

            // Star on top
            const starGeo = new THREE.OctahedronGeometry(0.12);
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 1.85;
            // Star spin animation logic will be in render loop
            star.userData = { rotate: true }; 
            treeGroup.add(star);

            // Snow System (Attached to the tree group)
            const snowGeo = new THREE.BufferGeometry();
            const snowCount = 400;
            const posArray = new Float32Array(snowCount * 3);
            
            for(let i = 0; i < snowCount * 3; i+=3) {
                posArray[i] = (Math.random() - 0.5) * 2; // x
                posArray[i+1] = Math.random() * 2 + 0.5; // y
                posArray[i+2] = (Math.random() - 0.5) * 2; // z
            }
            
            snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.02,
                transparent: true,
                opacity: 0.8
            });
            particles = new THREE.Points(snowGeo, snowMat);
            treeGroup.add(particles);

            // Light Glow
            const pointLight = new THREE.PointLight(0xffaa00, 1, 3);
            pointLight.position.set(0, 1, 0);
            treeGroup.add(pointLight);
        }

        function addOrnaments(y, radius, height) {
            const colors = [0xff0000, 0x0000ff, 0xffd700, 0xffffff];
            const count = 8; 

            for(let i=0; i<count; i++) {
                const angle = (i / count) * Math.PI * 2;
                // Place on the surface of the cone approximately
                const x = Math.cos(angle) * (radius * 0.8);
                const z = Math.sin(angle) * (radius * 0.8);
                
                const bulbGeo = new THREE.SphereGeometry(0.04, 16, 16);
                const color = colors[Math.floor(Math.random() * colors.length)];
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    emissive: color,
                    emissiveIntensity: 0.5 
                });

                const bulb = new THREE.Mesh(bulbGeo, mat);
                // Adjust height to sit on the cone slope
                bulb.position.set(x, y - height * 0.3, z);
                
                // Save for animation
                bulb.userData = { 
                    originalIntensity: 0.5, 
                    speed: Math.random() * 5, 
                    offset: Math.random() * 100 
                };
                
                ornaments.push(bulb);
                treeGroup.add(bulb);
            }
        }

        // --- Interaction ---
        function onSelect() {
            if (reticle.visible) {
                // If reticle is visible, move the tree there and show it
                treeGroup.position.setFromMatrixPosition(reticle.matrix);
                treeGroup.visible = true;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Render Loop ---
        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            // 1. Hit Test Logic (Find the floor)
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', function () {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            // 2. Animations
            if(treeGroup.visible) {
                const time = Date.now() * 0.001;

                // A. Blinking Lights
                ornaments.forEach(bulb => {
                    const intensity = Math.abs(Math.sin(time * bulb.userData.speed + bulb.userData.offset));
                    bulb.material.emissiveIntensity = intensity + 0.2;
                });

                // B. Rotating Star
                const star = treeGroup.children.find(c => c.userData.rotate);
                if(star) star.rotation.y += 0.02;

                // C. Falling Snow
                if(particles) {
                    const positions = particles.geometry.attributes.position.array;
                    for(let i = 1; i < positions.length; i+=3) {
                        positions[i] -= 0.005; // Move Y down
                        if(positions[i] < 0) { // Reset if hits floor
                            positions[i] = 2.0;
                        }
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
