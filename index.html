<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Strange Mobile AR</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <style>
        :root { --neon-orange: #ff9d00; }
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; }
        
        /* 视频背景层 */
        #cam-video {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            z-index: -1;
            transform: scaleX(-1); /* 后置摄像头通常不需要镜像，但如果是前置则需要 */
        }

        /* 3D 画布层 */
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* iOS 权限引导 UI */
        #start-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
            color: var(--neon-orange);
            text-align: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .btn {
            border: 2px solid var(--neon-orange);
            background: rgba(255, 157, 0, 0.1);
            color: var(--neon-orange);
            padding: 15px 30px;
            font-size: 18px;
            margin-top: 20px;
            border-radius: 5px;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 0 15px var(--neon-orange);
            transition: 0.2s;
        }
        .btn:active { background: var(--neon-orange); color: #000; }

        #hud {
            position: absolute;
            bottom: 30px; left: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

    <video id="cam-video" autoplay playsinline muted></video>
    
    <div id="canvas-container"></div>

    <div id="start-screen">
        <h1 style="text-shadow: 0 0 20px orange;">SANCTUM<br>MOBILE</h1>
        <p>需要访问摄像头与陀螺仪</p>
        <button class="btn" onclick="requestPermissions()">启动法阵</button>
    </div>

    <div id="hud">
        GYRO: WAITING...<br>
        TOUCH: ENABLED
    </div>

    <script>
        // --- 核心变量 ---
        let camera, scene, renderer, composer;
        let shieldGroup;
        let videoElement = document.getElementById('cam-video');
        
        // 交互状态
        let targetScale = 0; // 默认隐藏，点击屏幕出现
        let currentScale = 0;
        let baseRotation = { x: 0, y: 0 };
        
        // 陀螺仪数据
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };

        // --- 1. iOS 权限处理 (最关键的一步) ---
        async function requestPermissions() {
            const startBtn = document.querySelector('.btn');
            startBtn.innerText = "正在链接...";

            try {
                // 1. 请求摄像头 (后置)
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment', // 强制后置
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }, 
                    audio: false 
                });
                videoElement.srcObject = stream;
                // 修正镜像问题：后置摄像头不应该镜像，CSS中transform去掉
                videoElement.style.transform = 'none';

                // 2. 请求陀螺仪 (iOS 13+ 特有)
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    const response = await DeviceOrientationEvent.requestPermission();
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                    } else {
                        alert("需要陀螺仪权限来控制角度！");
                    }
                } else {
                    // 非 iOS 13+ 或安卓
                    window.addEventListener('deviceorientation', handleOrientation);
                }

                // 启动 3D 场景
                initThreeJS();
                document.getElementById('start-screen').style.display = 'none';
                
                // 默认展开魔法阵
                targetScale = 1;

            } catch (err) {
                alert("无法访问摄像头: " + err.message + "\n请确保使用 HTTPS 或 localhost");
                startBtn.innerText = "重试";
            }
        }

        function handleOrientation(event) {
            // 平滑处理数据
            deviceOrientation.alpha = event.alpha || 0; // 指南针方向
            deviceOrientation.beta = event.beta || 0;   // 前后倾斜 (-180, 180)
            deviceOrientation.gamma = event.gamma || 0; // 左右倾斜 (-90, 90)
            
            document.getElementById('hud').innerHTML = 
                `GYRO: ${Math.round(deviceOrientation.beta)} | ${Math.round(deviceOrientation.gamma)}<br>TOUCH: Active`;
        }

        // --- 2. Three.js 场景构建 ---
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // 不设置背景色，保持透明以显示 video
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 3;

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 后期处理 (发光)
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                2.0, 0.4, 0.1
            );
            composer.addPass(bloomPass);

            // 创建魔法阵 (复用之前的逻辑)
            createShield();

            // 触摸事件监听
            window.addEventListener('touchstart', onTouchStart);
            window.addEventListener('resize', onResize);

            animate();
        }

        function createShield() {
            shieldGroup = new THREE.Group();
            scene.add(shieldGroup);

            const layers = [
                { radius: 1.2, speed: 0.01, z: 0 },
                { radius: 0.9, speed: -0.02, z: 0.1 },
                { radius: 0.5, speed: 0.04, z: 0.2 }
            ];

            layers.forEach(layer => {
                const texture = createRuneTexture(512, Math.random());
                const mat = new THREE.MeshBasicMaterial({
                    map: texture,
                    color: 0xff9d00,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(layer.radius*2, layer.radius*2), mat);
                mesh.position.z = layer.z;
                mesh.userData.speed = layer.speed;
                shieldGroup.add(mesh);
            });
        }

        // 简化的纹理生成
        function createRuneTexture(size, seed) {
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.translate(size/2, size/2);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 10; ctx.shadowColor = '#fff';

            // 外圈
            ctx.beginPath(); ctx.arc(0,0, size/2 - 10, 0, Math.PI*2); ctx.stroke();
            // 随机几何
            for(let i=0; i<8; i++) {
                ctx.rotate(Math.PI/4);
                ctx.beginPath();
                ctx.moveTo(size/3, 0);
                ctx.lineTo(size/2-20, 10);
                ctx.stroke();
                // 方块
                ctx.strokeRect(size/4, -10, 20, 20);
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- 3. 交互逻辑 ---
        
        function onTouchStart() {
            // 点击屏幕切换开关
            if (targetScale < 0.1) targetScale = 1;
            else targetScale = 0;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. 处理缩放动画
            currentScale += (targetScale - currentScale) * 0.1;
            shieldGroup.scale.set(currentScale, currentScale, currentScale);

            // 2. 只有显示时才计算旋转和陀螺仪
            if (currentScale > 0.01) {
                // 自转
                shieldGroup.children.forEach(mesh => {
                    mesh.rotation.z += mesh.userData.speed;
                });

                // 陀螺仪控制整体角度 (将手机倾斜映射到魔法阵倾斜)
                // 这里做一个平滑插值
                const targetRotX = (deviceOrientation.beta - 45) * (Math.PI / 180); // 减45度是因为通常手机是斜着拿的
                const targetRotY = (deviceOrientation.gamma) * (Math.PI / 180);

                shieldGroup.rotation.x += (targetRotX - shieldGroup.rotation.x) * 0.1;
                shieldGroup.rotation.y += (targetRotY - shieldGroup.rotation.y) * 0.1;
            }

            composer.render();
        }
    </script>
</body>
</html>
