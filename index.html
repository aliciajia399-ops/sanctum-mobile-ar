<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åœ£è¯é­”æ³•æ ‘ AR</title>
    <style>
        body {
            margin: 0;
            background-color: #050510; /* æ·±è‰²èƒŒæ™¯ */
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
        }

        /* --- 2D UI æ ·å¼ --- */
        #landing-page, #preview-page {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f1c2e 0%, #040812 100%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.5s;
        }

        h1 {
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
        }

        p.subtitle {
            font-size: 14px;
            color: #a0aab5;
            text-align: center;
            margin-bottom: 30px;
            max-width: 300px;
        }

        .form-group {
            width: 100%;
            max-width: 320px;
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 12px;
            color: #ffd700;
            margin-bottom: 5px;
        }

        input, textarea {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        textarea { resize: none; height: 80px; }

        input:focus, textarea:focus {
            outline: none;
            border-color: #ffd700;
            background: rgba(255, 255, 255, 0.15);
        }

        .btn {
            background: linear-gradient(to right, #ffd700, #ffaa00);
            border: none;
            padding: 15px 40px;
            color: #000;
            font-weight: bold;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            transition: transform 0.2s;
        }

        .btn:active { transform: scale(0.95); }
        .btn:disabled { background: #555; color: #888; box-shadow: none; }

        /* --- AR Overlay UI --- */
        #ar-ui {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            display: none; /* ARå¼€å§‹åæ˜¾ç¤º */
            justify-content: center;
            gap: 20px;
            z-index: 5;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ°ç”»å¸ƒï¼Œé™¤äº†æŒ‰é’® */
        }

        .ar-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        #hint-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            pointer-events: none;
            display: none;
            z-index: 4;
            text-align: center;
        }

        /* éšè—çš„Canvasç”¨äºç”Ÿæˆæ–‡å­—è´´å›¾ */
        #textCanvas { display: none; }
    </style>
</head>
<body>

    <div id="landing-page">
        <h1>ğŸ„ åœ£è¯é­”æ³•æ ‘</h1>
        <p class="subtitle">å®šåˆ¶ä¸€æ£µåªå±äº TA çš„åœ£è¯æ ‘<br>åœ¨ AR é‡Œé€ä¸Šç¥ç¦</p>
        
        <div class="form-group">
            <label>ä½ çš„åå­— (From)</label>
            <input type="text" id="sender" placeholder="ä¾‹å¦‚ï¼šAlex">
        </div>
        <div class="form-group">
            <label>æƒ³é€ç»™è° (To)</label>
            <input type="text" id="recipient" placeholder="ä¾‹å¦‚ï¼šAlice">
        </div>
        <div class="form-group">
            <label>æƒ³è¯´çš„è¯ (Message)</label>
            <textarea id="message" placeholder="ç¥ä½ å¤©å¤©å¼€å¿ƒï¼Œå¿ƒæƒ³äº‹æˆï¼"></textarea>
        </div>

        <button class="btn" id="next-btn" disabled>ä¸‹ä¸€æ­¥</button>
    </div>

    <div id="preview-page" style="display: none;">
        <h1>âœ¨ å‡†å¤‡å°±ç»ª</h1>
        <p class="subtitle">å³å°†ç”Ÿæˆçš„ç¥ç¦å¡ç‰‡ï¼š</p>
        
        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; text-align: center; margin-bottom: 30px; border: 1px dashed #ffd700;">
            <h3 id="preview-title" style="color: #ffd700; margin: 0 0 10px 0;"></h3>
            <p id="preview-body" style="font-size: 16px; margin: 0;"></p>
        </div>

        <p class="subtitle" style="color: #ff5555; font-size: 12px;">
            âš ï¸ iPhone ç”¨æˆ·è¯·ä½¿ç”¨ "WebXR Viewer" App æ‰“å¼€<br>
            å¦åˆ™æ— æ³•å¯åŠ¨ AR æ¨¡å¼
        </p>

        <button class="btn" id="enter-ar-btn">è¿›å…¥ AR åœ£è¯æ ‘</button>
    </div>

    <div id="ar-ui">
        <button class="ar-btn" id="btn-disperse">ğŸ’¥ æ•£å¼€ (Disperse)</button>
        <button class="ar-btn" id="btn-assemble">ğŸ„ èšåˆ (Assemble)</button>
    </div>

    <div id="hint-overlay">è¯·å¯»æ‰¾å¹³å¦åœ°é¢<br>å‡ºç°å…‰åœˆåç‚¹å‡»å±å¹•æ”¾ç½®</div>

    <canvas id="textCanvas" width="512" height="256"></canvas>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
        import { ARButton } from 'https://unpkg.com/three@0.128.0/examples/jsm/webxr/ARButton.js';

        // --- å˜é‡å£°æ˜ ---
        let container, scene, camera, renderer;
        let controller;
        let reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        
        // æ ‘ä¸ç²’å­ç›¸å…³
        let treeGroup; 
        let particles = []; // å­˜å‚¨æ‰€æœ‰å¡ç‰‡/ç²’å­å¯¹è±¡
        let textMesh;       // ç¥ç¦è¯­ç‰Œå­
        let isPlaced = false;
        let animationState = 'assembled'; // 'assembled', 'dispersing', 'dispersed', 'assembling'
        
        // ç”¨æˆ·æ•°æ®
        const userData = { sender: '', recipient: '', message: '' };

        // äº¤äº’æ‰‹åŠ¿
        let touchStartPos = { x: 0, y: 0 };
        let touchStartDist = 0;
        let baseScale = 1;
        let baseRotationY = 0;

        // --- DOM å…ƒç´ å¼•ç”¨ ---
        const landingPage = document.getElementById('landing-page');
        const previewPage = document.getElementById('preview-page');
        const nextBtn = document.getElementById('next-btn');
        const enterArBtn = document.getElementById('enter-ar-btn');
        const arUi = document.getElementById('ar-ui');
        const hintOverlay = document.getElementById('hint-overlay');
        
        const inputs = [document.getElementById('sender'), document.getElementById('recipient'), document.getElementById('message')];

        // --- 1. 2D UI é€»è¾‘ ---

        // è¡¨å•éªŒè¯
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                const allFilled = inputs.every(i => i.value.trim() !== '');
                nextBtn.disabled = !allFilled;
            });
        });

        // ç‚¹å‡»ä¸‹ä¸€æ­¥
        nextBtn.addEventListener('click', () => {
            userData.sender = document.getElementById('sender').value;
            userData.recipient = document.getElementById('recipient').value;
            userData.message = document.getElementById('message').value;

            // æ›´æ–°é¢„è§ˆ
            document.getElementById('preview-title').innerText = `${userData.recipient}`;
            document.getElementById('preview-body').innerText = `${userData.message}\n\nâ€”â€” ${userData.sender}`;

            // åˆ‡æ¢é¡µé¢
            landingPage.style.opacity = 0;
            setTimeout(() => {
                landingPage.style.display = 'none';
                previewPage.style.display = 'flex';
            }, 500);
        });

        // ç‚¹å‡»è¿›å…¥ AR
        enterArBtn.addEventListener('click', () => {
            previewPage.style.display = 'none';
            initAR(); // åˆå§‹åŒ– 3D åœºæ™¯
        });

        // AR æŒ‰é’®é€»è¾‘
        document.getElementById('btn-disperse').addEventListener('click', () => {
            disperseTree();
        });
        document.getElementById('btn-assemble').addEventListener('click', () => {
            assembleTree();
        });


        // --- 2. Three.js ä¸ AR åˆå§‹åŒ– ---

        function initAR() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffd700, 1.5); // é‡‘è‰²é˜³å…‰
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // æ·»åŠ  WebXR æŒ‰é’®
            const btn = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
            document.body.appendChild(btn);
            
            // è‡ªåŠ¨ç‚¹å‡» AR æŒ‰é’® (æ¨¡æ‹Ÿç”¨æˆ·ç‚¹å‡»ï¼ŒæŸäº›æµè§ˆå™¨å¯èƒ½æ‹¦æˆªï¼Œéœ€è¦ç”¨æˆ·æ‰‹åŠ¨ç‚¹)
            // btn.click(); 
            // æç¤ºç”¨æˆ·ç‚¹å‡»å±å¹•ä¸‹æ–¹çš„ "START AR"

            hintOverlay.style.display = 'block';

            // å…‰æ ‡ (Reticle)
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // åˆ›å»ºæ ‘ (åˆå§‹éšè—)
            createTreeGroup();
            
            // æ§åˆ¶å™¨ (ç”¨äºç‚¹å‡»æ”¾ç½®)
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);

            // æ¸²æŸ“å¾ªç¯
            renderer.setAnimationLoop(render);

            // æ·»åŠ æ‰‹åŠ¿ç›‘å¬ (ç”¨äºæ”¾ç½®åçš„æ—‹è½¬å’Œç¼©æ”¾)
            addGestures();
        }

        // --- 3. åœ£è¯æ ‘é€»è¾‘ (ç²’å­ç³»ç»Ÿ) ---

        function createTreeGroup() {
            treeGroup = new THREE.Group();
            treeGroup.visible = false; // è¿˜æ²¡æ”¾ç½®
            scene.add(treeGroup);

            // 3.1 æ ¸å¿ƒå‘å…‰æŸ± (ä½œä¸ºæ ‘å¹²éšçº¦å¯è§)
            const coreGeo = new THREE.CylinderGeometry(0.05, 0.2, 1.5, 32);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                transparent: true, 
                opacity: 0.3,
                blending: THREE.AdditiveBlending 
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.position.y = 0.75;
            treeGroup.add(core);

            // 3.2 ç²’å­å¡ç‰‡ç”Ÿæˆ
            // æˆ‘ä»¬ç”Ÿæˆ 200 ä¸ªå°å¡ç‰‡ï¼ŒæŒ‰èºæ—‹æ’åˆ—æˆåœ†é”¥ä½“
            const particleCount = 200;
            const treeHeight = 1.5;
            const maxRadius = 0.6;
            
            const cardGeo = new THREE.PlaneGeometry(0.08, 0.1); // ç±»ä¼¼ç…§ç‰‡çš„æ¯”ä¾‹
            // å®šä¹‰å‡ ç§é¢œè‰²æ¥æ¨¡æ‹Ÿä¸åŒçš„ç…§ç‰‡/è£…é¥°
            const colors = [0xffffff, 0xffd700, 0xff0000, 0x00ff00, 0x00aaff];

            for (let i = 0; i < particleCount; i++) {
                const mat = new THREE.MeshStandardMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    side: THREE.DoubleSide,
                    roughness: 0.4,
                    metalness: 0.6
                });

                const mesh = new THREE.Mesh(cardGeo, mat);
                
                // --- è®¡ç®— "ç»„è£…çŠ¶æ€" (æ ‘å½¢) çš„ä½ç½® ---
                // y: ä»ä¸‹åˆ°ä¸Š (0 åˆ° treeHeight)
                // t: å½’ä¸€åŒ–é«˜åº¦ (0 åˆ° 1)
                const t = i / particleCount; 
                const y = t * treeHeight + 0.2; // ç¦»åœ°ä¸€ç‚¹
                const radius = (1 - t) * maxRadius; // è¶Šå¾€ä¸Šè¶Šçª„
                const angle = i * 0.5; // èºæ—‹è§’åº¦
                
                const targetX = Math.cos(angle) * radius;
                const targetZ = Math.sin(angle) * radius;
                
                // ç¨å¾®éšæœºä¸€ç‚¹æ—‹è½¬ï¼Œçœ‹èµ·æ¥æ›´è‡ªç„¶
                const targetRotX = (Math.random() - 0.5);
                const targetRotY = angle + Math.PI/2; // é¢å‘å¤–
                const targetRotZ = (Math.random() - 0.5);

                // --- è®¡ç®— "æ•£å¼€çŠ¶æ€" (æ˜Ÿäº‘) çš„ä½ç½® ---
                // éšæœºåˆ†å¸ƒåœ¨ä»¥æ ‘é¡¶ä¸ºä¸­å¿ƒçš„å¤§çƒä½“ä¸­
                const disperseRadius = 1.5 + Math.random() * 1.0;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                
                const dispX = disperseRadius * Math.sin(phi) * Math.cos(theta);
                const dispY = disperseRadius * Math.sin(phi) * Math.sin(theta) + 1.0; // æŠ¬é«˜ä¸€ç‚¹
                const dispZ = disperseRadius * Math.cos(phi);

                // å­˜å‚¨æ•°æ®åˆ° userData
                mesh.userData = {
                    assembled: { x: targetX, y: y, z: targetZ, rx: targetRotX, ry: targetRotY, rz: targetRotZ },
                    dispersed: { x: dispX, y: dispY, z: dispZ, rx: Math.random()*Math.PI, ry: Math.random()*Math.PI, rz: Math.random()*Math.PI },
                    current: { x: 0, y: 0, z: 0 }, // åŠ¨ç”»ä¸­çš„å®æ—¶ä½ç½®
                    speed: 0.02 + Math.random() * 0.03 // æ¯ä¸ªç²’å­é€Ÿåº¦ä¸åŒ
                };

                // åˆå§‹ä½ç½®è®¾ä¸º dispersed (ä»å¤©è€Œé™çš„æ•ˆæœ) è¿˜æ˜¯ assembled?
                // å‚è€ƒéœ€æ±‚ï¼šå…ˆæ”¾ç½®ï¼Œç„¶åç”¨æˆ·å¯ä»¥ç©æ•£å¼€/èšåˆã€‚
                // æˆ‘ä»¬è®©å®ƒåˆå§‹å°±æ˜¯ assembled çŠ¶æ€ã€‚
                mesh.position.set(targetX, y, targetZ);
                mesh.rotation.set(targetRotX, targetRotY, targetRotZ);

                particles.push(mesh);
                treeGroup.add(mesh);
            }

            // 3.3 é¡¶éƒ¨æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(0.15);
            const starMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 1 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = treeHeight + 0.2;
            // æ˜Ÿæ˜Ÿä¹Ÿä½œä¸ºä¸€ä¸ªç²’å­ï¼Œä½†åªæœ‰ç®€å•çš„å‡é™
            star.userData = {
                assembled: { x:0, y: treeHeight + 0.2, z:0, rx:0, ry:0, rz:0 },
                dispersed: { x:0, y: treeHeight + 1.5, z:0, rx: Math.random(), ry: Math.random(), rz: Math.random() },
                speed: 0.05
            };
            particles.push(star);
            treeGroup.add(star);

            // 3.4 ç”Ÿæˆæ–‡å­—ç‰Œ
            createGreetingText();
        }

        // ç”Ÿæˆæ–‡å­—çº¹ç†
        function createGreetingText() {
            const canvas = document.getElementById('textCanvas');
            const ctx = canvas.getContext('2d');
            
            // èƒŒæ™¯
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // æ–‡å­—è®¾ç½®
            ctx.font = 'bold 30px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = '#ffffff';
            ctx.fillText(`To: ${userData.recipient}`, centerX, centerY - 60);
            
            ctx.font = '24px sans-serif';
            ctx.fillStyle = '#ffd700';
            // ç®€å•å¤„ç†é•¿æ–‡æœ¬æ¢è¡Œ (è¿™é‡Œç®€åŒ–ï¼Œåªå–å‰20ä¸ªå­—)
            let msg = userData.message.length > 15 ? userData.message.substring(0, 15) + '...' : userData.message;
            ctx.fillText(msg, centerX, centerY);

            ctx.font = 'italic 20px sans-serif';
            ctx.fillStyle = '#cccccc';
            ctx.fillText(`From: ${userData.sender}`, centerX, centerY + 60);

            // åˆ›å»ºæè´¨
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const geo = new THREE.PlaneGeometry(0.8, 0.4);
            
            textMesh = new THREE.Mesh(geo, mat);
            textMesh.position.set(0, 0.5, 0.6); // æ”¾åœ¨æ ‘å‰é¢
            textMesh.visible = false; // åˆå§‹éšè—ï¼ŒèšåˆåŠ¨ç”»å®Œæˆåæ˜¾ç¤º
            treeGroup.add(textMesh);
        }

        // --- 4. åŠ¨ç”»é€»è¾‘ (æ•£å¼€/èšåˆ) ---

        function disperseTree() {
            animationState = 'dispersing';
            textMesh.visible = false; // æ•£å¼€æ—¶éšè—æ–‡å­—
        }

        function assembleTree() {
            animationState = 'assembling';
        }

        function updateParticles() {
            if (!treeGroup.visible) return;

            // ç®€å•çš„æ’å€¼åŠ¨ç”»
            let allDone = true;

            particles.forEach(p => {
                const target = (animationState === 'assembling' || animationState === 'assembled') 
                    ? p.userData.assembled 
                    : p.userData.dispersed;

                // Lerp ä½ç½®
                p.position.x += (target.x - p.position.x) * p.userData.speed;
                p.position.y += (target.y - p.position.y) * p.userData.speed;
                p.position.z += (target.z - p.position.z) * p.userData.speed;

                // Lerp æ—‹è½¬
                p.rotation.x += (target.rx - p.rotation.x) * p.userData.speed;
                p.rotation.y += (target.ry - p.rotation.y) * p.userData.speed;
                p.rotation.z += (target.rz - p.rotation.z) * p.userData.speed;

                // æ£€æŸ¥æ˜¯å¦è¿˜åœ¨è¿åŠ¨ (ç®€å•è·ç¦»æ£€æŸ¥)
                if (Math.abs(p.position.y - target.y) > 0.01) {
                    allDone = false;
                }

                // å¦‚æœæ˜¯æ•£å¼€çŠ¶æ€ï¼ŒåŠ ä¸€ç‚¹æ¼‚æµ®æ„Ÿ
                if (animationState === 'dispersed' || (animationState === 'dispersing' && allDone)) {
                    p.rotation.y += 0.01; 
                }
            });

            // çŠ¶æ€è½¬æ¢
            if (allDone) {
                if (animationState === 'assembling') {
                    animationState = 'assembled';
                    // èšåˆå®Œæˆåæ˜¾ç¤ºæ–‡å­—
                    textMesh.visible = true;
                    // æ–‡å­—æœ‰ä¸ªç®€å•çš„æµ®åŠ¨åŠ¨ç”»
                } else if (animationState === 'dispersing') {
                    animationState = 'dispersed';
                }
            }
            
            // æ–‡å­—ç‰Œå§‹ç»ˆé¢å‘æ‘„åƒæœº (Billboard)
            if (textMesh && textMesh.visible) {
                // åªåœ¨Yè½´æ—‹è½¬ï¼Œä¿æŒå‚ç›´
                textMesh.lookAt(camera.position);
            }
        }

        // --- 5. äº¤äº’é€»è¾‘ (ç‚¹å‡»æ”¾ç½® & æ‰‹åŠ¿) ---

        function onSelect() {
            if (reticle.visible && !isPlaced) {
                // ç¬¬ä¸€æ¬¡æ”¾ç½®
                treeGroup.position.setFromMatrixPosition(reticle.matrix);
                treeGroup.visible = true;
                isPlaced = true;
                
                // æ˜¾ç¤º AR UI
                arUi.style.display = 'flex';
                hintOverlay.innerHTML = 'æ‹–åŠ¨æ—‹è½¬ â€¢ åŒæŒ‡ç¼©æ”¾';
                setTimeout(() => { hintOverlay.style.display = 'none'; }, 3000);
            }
        }

        function addGestures() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartPos.x = e.touches[0].pageX;
                    touchStartPos.y = e.touches[0].pageY;
                    baseRotationY = treeGroup.rotation.y;
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    touchStartDist = Math.sqrt(dx*dx + dy*dy);
                    baseScale = treeGroup.scale.x;
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                if (!isPlaced) return;

                if (e.touches.length === 1) {
                    // å•æŒ‡æ—‹è½¬
                    const deltaX = e.touches[0].pageX - touchStartPos.x;
                    treeGroup.rotation.y = baseRotationY + deltaX * 0.01;
                } else if (e.touches.length === 2) {
                    // åŒæŒ‡ç¼©æ”¾
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    let newScale = baseScale * (dist / touchStartDist);
                    newScale = Math.max(0.1, Math.min(newScale, 3.0)); // é™åˆ¶ç¼©æ”¾èŒƒå›´
                    treeGroup.scale.set(newScale, newScale, newScale);
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 6. æ¸²æŸ“å¾ªç¯ ---

        function render(timestamp, frame) {
            // Hit Test (æ£€æµ‹åœ°é¢)
            if (frame && !isPlaced) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', function () {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                        arUi.style.display = 'none';
                        isPlaced = false;
                        treeGroup.visible = false;
                        landingPage.style.display = 'flex';
                        landingPage.style.opacity = 1;
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }

            // æ›´æ–°åŠ¨ç”»
            updateParticles();

            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
