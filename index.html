<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Debugger</title>
    
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        
        #input-video {
            position: fixed; top: 16px; right: 16px; width: 100px; height: auto;
            border-radius: 10px; border: 2px solid rgba(255, 215, 0, 0.5);
            transform: scaleX(-1); z-index: 20; background: #222; opacity: 0.8;
        }

        #three-canvas { display: block; width: 100%; height: 100%; z-index: 10; }

        /* 调试日志窗口 */
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%; height: 50%;
            pointer-events: none; z-index: 100;
            padding: 10px; box-sizing: border-box;
            color: #0f0; text-shadow: 1px 1px 0 #000;
            overflow-y: auto; font-size: 12px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        .log-error { color: #ff3333; font-weight: bold; }
        .log-warn { color: #ffff33; }
        .log-info { color: #ffffff; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: gold; font-size: 20px; font-weight: bold; z-index: 50;
            text-align: center; pointer-events: none;
            text-shadow: 0 0 10px #000;
        }
    </style>
</head>
<body>

    <div id="debug-console"></div>
    <div id="loading">正在初始化图形引擎...</div>
    <video id="input-video" playsinline muted></video>
    <canvas id="three-canvas"></canvas>

    <script>
        // === 屏幕日志工具 (为了让你看到报错) ===
        const consoleDiv = document.getElementById('debug-console');
        function log(msg, type='info') {
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            div.className = `log-${type}`;
            consoleDiv.appendChild(div);
            console.log(msg); // 同时也打到后台
        }
        window.onerror = function(msg, source, lineno) {
            log(`ERROR: ${msg} (Line ${lineno})`, 'error');
        };

        // === 核心变量 ===
        let scene, camera, renderer, clock;
        let mainGroup, particleGeo, particleMat;
        let isAutoMode = true; // 默认自动播放，直到手势识别成功

        // === 1. 立即启动 Three.js (不等待摄像头) ===
        function initThree() {
            log("启动 Three.js...");
            try {
                const canvas = document.getElementById('three-canvas');
                renderer = new THREE.WebGLRenderer({ canvas, alpha: false, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                scene = new THREE.Scene();
                scene.background = new THREE.Color('#050505');

                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.set(0, 1, 8);

                mainGroup = new THREE.Group();
                scene.add(mainGroup);

                // 生成几何体
                generateKnot();

                // 灯光
                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffd700, 1.5);
                dirLight.position.set(2, 5, 5);
                scene.add(dirLight);

                clock = new THREE.Clock();
                log("Three.js 启动成功，开始渲染画面...");
                document.getElementById('loading').innerText = "图形引擎就绪\n等待摄像头...";
                
                animate(); // 立即开始动画循环
            } catch (e) {
                log(`Three.js 初始化失败: ${e.message}`, 'error');
            }
        }

        // === 2. 生成程序化几何体 (绳结) ===
        function generateKnot() {
            const geometry = new THREE.TorusKnotGeometry(1.2, 0.4, 120, 20);
            const posAttr = geometry.getAttribute('position');
            const count = posAttr.count; // 顶点数
            
            const positions = [];
            const colors = [];
            
            for(let i=0; i<count; i++) {
                positions.push(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
                colors.push(1.0, 0.8, 0.0); // 金色
            }

            particleGeo = new THREE.BufferGeometry();
            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // 创建纹理
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(c);

            particleMat = new THREE.PointsMaterial({
                map: tex, size: 0.1, vertexColors: true,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true
            });

            const particles = new THREE.Points(particleGeo, particleMat);
            mainGroup.add(particles);
        }

        // === 3. 动画循环 ===
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (isAutoMode) {
                // 如果手势没准备好，就自动旋转
                mainGroup.rotation.y = time * 0.5;
                mainGroup.rotation.x = Math.sin(time * 0.3) * 0.2;
                const s = 1 + Math.sin(time * 2) * 0.1;
                mainGroup.scale.set(s, s, s);
            }

            renderer.render(scene, camera);
        }

        // === 4. 尝试启动 AI (带超时) ===
        async function startAI() {
            log("尝试加载 MediaPipe...");
            
            // 5秒超时保护
            const timeout = setTimeout(() => {
                log("MediaPipe 加载超时 (可能是网络问题)", 'warn');
                log("已切换到自动演示模式", 'info');
                document.getElementById('loading').style.display = 'none';
            }, 8000);

            try {
                const video = document.getElementById('input-video');
                
                // 检查 Hands 是否存在
                if (typeof Hands === 'undefined') {
                    throw new Error("Hands 库未加载，请检查网络 (CDN)");
                }

                const hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});
                
                hands.setOptions({maxNumHands: 1, modelComplexity: 0}); // 用最轻量的模型
                
                hands.onResults(results => {
                    clearTimeout(timeout); // 成功连接，清除超时
                    document.getElementById('loading').style.display = 'none';
                    
                    if (results.multiHandLandmarks.length > 0) {
                        isAutoMode = false; // 接管控制
                        const lm = results.multiHandLandmarks[0];
                        const x = lm[9].x;
                        const y = lm[9].y;
                        
                        // 简单的控制逻辑
                        mainGroup.rotation.y = (x - 0.5) * 4;
                        mainGroup.rotation.x = (y - 0.5) * 4;
                        
                        // 距离计算
                        const dist = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                        const s = Math.min(Math.max(dist * 4, 0.5), 2.0);
                        mainGroup.scale.set(s, s, s);
                    } else {
                        // 没手的时候短暂回自动，或者保持不动
                    }
                });

                log("请求摄像头权限...");
                const cameraUtils = new Camera(video, {
                    onFrame: async () => { await hands.send({image: video}); },
                    width: 640, height: 480
                });
                
                await cameraUtils.start();
                log("摄像头启动成功，AI 运行中");

            } catch (e) {
                clearTimeout(timeout);
                log(`AI 启动失败: ${e.message}`, 'error');
                log("将保持在自动演示模式", 'warn');
                document.getElementById('loading').style.display = 'none';
            }
        }

        // === 入口 ===
        window.onload = function() {
            initThree(); // 先画图
            startAI();   // 再搞 AI
        };

        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

    </script>
</body>
</html>
